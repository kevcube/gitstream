{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"/:\\ gitStream gitStream automates your reviews, so you can focus human effort on what matters most. Not all Pull Requests are the same. Some reviews can be automated, like changes using a specific API (deprecated, sensitive), changes that are non-functional, like docs or tests, or even reformatting code. Automate these reviews to reduce context switches by assigning specific people to review, approve, or even merge simple changes that passed all checks, and more. Quick Start Take these three steps to see how gitStream works; later on you can learn about the .cm file, see some automation examples and learn how to create and edit your automation. GitHub GitLab BitBucket Install gitStream for free in GitHub Configure your repository using the instructions for GitHub That's it! Now sit back and watch gitStream automation rules on your next PR (You don\u2019t have to merge it) Note When installing for GitHub, gitStream can be installed for one repo, specific repos, or all repos in your organization. We recommend installing for all , as it will also cover new repos you add in the future. You can change this setting at any time later. Follow the installation instructions for GitLab here Coming soon Features \ud83d\udcd0 Building Custom Rules PR Complexity Multiple sources Code change variables Branch details & history \ud83e\udd16 gitStream engine Auto-merge PRs Custom PR labels Require specific reviewers Automated change requests Increase quality requirements Based on Jinja2 template engine Continuous Merge Continuous Merge (CM) is the practice of automating the merge path by classifying pull requests based on change type, size, and complexity to allow work to flow more efficiently. learn more about the .cm file automation examples","title":"Overview"},{"location":"#gitstream","text":"gitStream automates your reviews, so you can focus human effort on what matters most. Not all Pull Requests are the same. Some reviews can be automated, like changes using a specific API (deprecated, sensitive), changes that are non-functional, like docs or tests, or even reformatting code. Automate these reviews to reduce context switches by assigning specific people to review, approve, or even merge simple changes that passed all checks, and more.","title":"/:\\ gitStream"},{"location":"#quick-start","text":"Take these three steps to see how gitStream works; later on you can learn about the .cm file, see some automation examples and learn how to create and edit your automation. GitHub GitLab BitBucket Install gitStream for free in GitHub Configure your repository using the instructions for GitHub That's it! Now sit back and watch gitStream automation rules on your next PR (You don\u2019t have to merge it) Note When installing for GitHub, gitStream can be installed for one repo, specific repos, or all repos in your organization. We recommend installing for all , as it will also cover new repos you add in the future. You can change this setting at any time later. Follow the installation instructions for GitLab here Coming soon","title":"Quick Start"},{"location":"#features","text":"\ud83d\udcd0 Building Custom Rules PR Complexity Multiple sources Code change variables Branch details & history \ud83e\udd16 gitStream engine Auto-merge PRs Custom PR labels Require specific reviewers Automated change requests Increase quality requirements Based on Jinja2 template engine","title":"Features"},{"location":"#continuous-merge","text":"Continuous Merge (CM) is the practice of automating the merge path by classifying pull requests based on change type, size, and complexity to allow work to flow more efficiently. learn more about the .cm file automation examples","title":"Continuous Merge"},{"location":"automation-actions/","text":"Automation actions Actions are the end results of the automation described in your .cm file. Note The icons for Git providers indicate the actions supported by each provider. GitHub GitLab Overview gitStream executes actions in the order they are listed. If an action result fails, following actions will not be executed. add-comment add-label add-labels add-reviewers approve close merge set-required-approvals require-reviewers request-changes Note Multiple actions can be listed in a single automation. The actions are invoked one by one. Dynamic actions arguments Arguments values a dynamic value is supported using expressions based on Jinja2 syntax, and includes gitStream context variables, for example: automations : pr_complexity : if : - true run : - action : add-comment@v1 args : comment : \"Estimated {{ branch | estimatedReviewTime }} minutes to review\" Reference add-comment This action, once triggered, adds a comment to the PR. This is a manged action, when a PR updates, the existing comments that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description comment Required String Sets the comment, markdown is supported example automations : senior_review : if : - {{ files | match ( term = 'core/' ) | some }} run : - action : add-comment@v1 args : comment : | Core service update (Updates API) add-label This action, once triggered, adds a label to the PR. This is a manged action, when a PR updates, the existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description label Required String The label text any string can work color Optional String The color in hex, for example: 'FEFEFE' (you can also add # prefix #FEFEFE ) example automations : senior_review : if : - {{ files | match ( term = 'api/' ) | some }} run : - action : add-label@v1 args : label : api-change add-labels This action, once triggered, adds a list of labels to the PR. This is a manged action, when a PR updates existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description labels Required [String] The list of text labels add-reviewers This action, once triggered, sets a specific reviewer. Args Usage Type Description reviewers Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. owner/team team_reviewers Optional [String] Sets required team reviewers without a prefix team unless_reviewers_set Optional Bool When true , the reviewers are not added if the PR has already assigned reviewers. It is set to false by default example automations : senior_review : if : - {{ files | match ( term = 'src/ui/' ) }} run : - action : add-reviewers@v1 args : reviewers : [ popeye , olive , acme/team-a ] approve This action, once triggered, approves the PR for merge. This is a manged action, when a PR updates existing approval by gitStream is re-evaluated and removed if no longer applicable. example automations : small_change : if : - {{ source.diff.files | isFormattingChange }} run : - action : approve@v1 close This action, once triggered, close the PR without merging. example automations : close_ui_changes_by_non_ui : if : - {{ files | match ( regex = r / src \\ / views /) | some }} - {{ pr.author_teams | match ( term = 'ui-team' ) | nope }} run : - action : add-comment@v1 args : comment : | Please contact a member of `ui-team` team if you need to make changes to files in `src/views` - action : close@v1 merge Once triggered, merge the PR if possible. It can set to wait for required checks to pass or ignore checks. Args Usage Type Description wait_for_all_checks Optional Boolean By default false , so only Required checks can block merge, when true the action won't merge even if non-Required check fail rebase_on_merge Optional Boolean By default false , when merging use rebase mode squash_on_merge Optional Boolean By default false , when merging use squash mode example automations : small_change : if : - {{ files | allDocs }} run : - action : merge@v1 args : rebase_on_merge : true set-required-approvals This action, once triggered, blocks PR merge till the desired reviewers approved the PR. The actions fail the check to prevent the PR for merge. Args Usage Type Description approvals Required Integer Sets the number of required reviewer approvals for merge for that PR example automations : double_review : if : - {{ files | match ( regex = r / agent \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2 Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub. request-changes This action, once triggered, request changes on the PR. As long as request change is set, gitStream will block the PR merge. This is a manged action, when a PR updates existing change request by gitStream is re-evaluated and removed if no longer applicable. Args Usage Type Description comment Required [String] The desired request changes comment example automations : catch_deprecated : if : - {{ source.diff.files | matchDiffLines ( regex = r / ^ [+] . * oldFetch \\ (/ ' ) | some }} run : - action : request-changes@v1 args : comment : | You have used deprecated API `oldFetch`, use `newFetch` instead. Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub. require-reviewers This action, once triggered, requires a specific reviewer approval. The PR merge is blocked till approved by either of the listed users or teams. Args Usage Type Description reviewers Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. owner/team . Merge is blocked till approved by either of the listed users also_assign Optional Bool true by default, also assign the specified users as reviewers example automations : senior_review : if : - {{ files | match ( regex = r / src \\ / ui \\ //) | some }} run : - action : require-reviewers@v1 args : reviewers : [ popeye , olive , acme/team-a ] Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.","title":"Automation actions"},{"location":"automation-actions/#automation-actions","text":"Actions are the end results of the automation described in your .cm file. Note The icons for Git providers indicate the actions supported by each provider. GitHub GitLab","title":"Automation actions"},{"location":"automation-actions/#overview","text":"gitStream executes actions in the order they are listed. If an action result fails, following actions will not be executed. add-comment add-label add-labels add-reviewers approve close merge set-required-approvals require-reviewers request-changes Note Multiple actions can be listed in a single automation. The actions are invoked one by one.","title":"Overview"},{"location":"automation-actions/#dynamic-actions-arguments","text":"Arguments values a dynamic value is supported using expressions based on Jinja2 syntax, and includes gitStream context variables, for example: automations : pr_complexity : if : - true run : - action : add-comment@v1 args : comment : \"Estimated {{ branch | estimatedReviewTime }} minutes to review\"","title":"Dynamic actions arguments"},{"location":"automation-actions/#reference","text":"","title":"Reference"},{"location":"automation-actions/#add-comment","text":"This action, once triggered, adds a comment to the PR. This is a manged action, when a PR updates, the existing comments that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description comment Required String Sets the comment, markdown is supported example automations : senior_review : if : - {{ files | match ( term = 'core/' ) | some }} run : - action : add-comment@v1 args : comment : | Core service update (Updates API)","title":"add-comment  "},{"location":"automation-actions/#add-label","text":"This action, once triggered, adds a label to the PR. This is a manged action, when a PR updates, the existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description label Required String The label text any string can work color Optional String The color in hex, for example: 'FEFEFE' (you can also add # prefix #FEFEFE ) example automations : senior_review : if : - {{ files | match ( term = 'api/' ) | some }} run : - action : add-label@v1 args : label : api-change","title":"add-label  "},{"location":"automation-actions/#add-labels","text":"This action, once triggered, adds a list of labels to the PR. This is a manged action, when a PR updates existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description labels Required [String] The list of text labels","title":"add-labels  "},{"location":"automation-actions/#add-reviewers","text":"This action, once triggered, sets a specific reviewer. Args Usage Type Description reviewers Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. owner/team team_reviewers Optional [String] Sets required team reviewers without a prefix team unless_reviewers_set Optional Bool When true , the reviewers are not added if the PR has already assigned reviewers. It is set to false by default example automations : senior_review : if : - {{ files | match ( term = 'src/ui/' ) }} run : - action : add-reviewers@v1 args : reviewers : [ popeye , olive , acme/team-a ]","title":"add-reviewers  "},{"location":"automation-actions/#approve","text":"This action, once triggered, approves the PR for merge. This is a manged action, when a PR updates existing approval by gitStream is re-evaluated and removed if no longer applicable. example automations : small_change : if : - {{ source.diff.files | isFormattingChange }} run : - action : approve@v1","title":"approve  "},{"location":"automation-actions/#close","text":"This action, once triggered, close the PR without merging. example automations : close_ui_changes_by_non_ui : if : - {{ files | match ( regex = r / src \\ / views /) | some }} - {{ pr.author_teams | match ( term = 'ui-team' ) | nope }} run : - action : add-comment@v1 args : comment : | Please contact a member of `ui-team` team if you need to make changes to files in `src/views` - action : close@v1","title":"close  "},{"location":"automation-actions/#merge","text":"Once triggered, merge the PR if possible. It can set to wait for required checks to pass or ignore checks. Args Usage Type Description wait_for_all_checks Optional Boolean By default false , so only Required checks can block merge, when true the action won't merge even if non-Required check fail rebase_on_merge Optional Boolean By default false , when merging use rebase mode squash_on_merge Optional Boolean By default false , when merging use squash mode example automations : small_change : if : - {{ files | allDocs }} run : - action : merge@v1 args : rebase_on_merge : true","title":"merge  "},{"location":"automation-actions/#set-required-approvals","text":"This action, once triggered, blocks PR merge till the desired reviewers approved the PR. The actions fail the check to prevent the PR for merge. Args Usage Type Description approvals Required Integer Sets the number of required reviewer approvals for merge for that PR example automations : double_review : if : - {{ files | match ( regex = r / agent \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2 Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.","title":"set-required-approvals "},{"location":"automation-actions/#request-changes","text":"This action, once triggered, request changes on the PR. As long as request change is set, gitStream will block the PR merge. This is a manged action, when a PR updates existing change request by gitStream is re-evaluated and removed if no longer applicable. Args Usage Type Description comment Required [String] The desired request changes comment example automations : catch_deprecated : if : - {{ source.diff.files | matchDiffLines ( regex = r / ^ [+] . * oldFetch \\ (/ ' ) | some }} run : - action : request-changes@v1 args : comment : | You have used deprecated API `oldFetch`, use `newFetch` instead. Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.","title":"request-changes "},{"location":"automation-actions/#require-reviewers","text":"This action, once triggered, requires a specific reviewer approval. The PR merge is blocked till approved by either of the listed users or teams. Args Usage Type Description reviewers Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. owner/team . Merge is blocked till approved by either of the listed users also_assign Optional Bool true by default, also assign the specified users as reviewers example automations : senior_review : if : - {{ files | match ( regex = r / src \\ / ui \\ //) | some }} run : - action : require-reviewers@v1 args : reviewers : [ popeye , olive , acme/team-a ] Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.","title":"require-reviewers "},{"location":"cm-file/","text":"Overview Continuous Merge automation files have a .cm extension. In a repository, gitStream loads and parse the .cm directory, which can have multiple automation files, each of which is evaluated independently. You can edit the .cm files and add your own checks and rules. Check out the Automation examples . Automation rules There are two types of automation rules: repository level rules and organization level rules. Repository level rules are set by creating a special .cm directory in the repository root. Automation rules are specified in files in this directory, which can have any name but must end with .cm . Organization level rules are defined by creating a special repository named cm in the organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. When organization level rules are defines, repository level automation shall take precedence and override organization automation when having the same identifier. An autoamtion identifier is a compistion of the CM file name and the automation name. For example when safe_changes is defined in gitstream.cm then the automation identifier shall be gitstream/safe_changes Tip You can exclude certain repositoires per automation file using the config.ignore_repositories Repository automation rules Repository automation rules are set by creating a special .cm directory in your repository root. Automation rules are specified in files in this directory, these files can have any name but ends with .cm . By default, you start with a single automation file .cm/gitstream.cm . Every file is parsed independently, and the parsing results are combined and executed. Specifically: Automation rules are allowed to have same name in different .cm files The config section is defined per .cm file (except config.admin ) Any accessory expression defined in each file scope, therefore cannot be reused in another file (but it can be duplicated) When configured correctly, your repository directory structure should look like that (for GitHub): Repsository automation rules . \u251c\u2500 .cm/ \u2502 \u2514\u2500 *.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml Note The .cm/gitstream.cm is special, as it allows for repository level configuration such as config.admin . Organization automation rules Organization automation rules are defined by creating a special repository cm in your organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. When configured correctly, the cm repository directory structure should look like that (for GitHub): Repsository automation rules . \u251c\u2500 *.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml For each PR the following automation rules are applied: Repository level rules Organization level rules, unless with the same identifier as a repository level automation When organization level rules are defined, then the CI/CD will be executed on the cm repository on behalf of the PR repository. The .cm automation file Context variables gitStream includes a collection of variables called contexts. These variable has all the inputs you need to code your automation, including files names and paths, code that was changed or who did the change. See more here . Filter functions Filter functions are essentially callable functions that can be applied to variables. They are called with a pipe operator | and can take arguments inside parentheses ( ) . The logic expressions are based on Jinja2 syntax, supported by Nunjucks library. See more about the Nunjucks built-in filters here , and about gitStream built-in filters here . Automation actions Specify the desired automations that are triggered when all conditions are met, read more here . Each automation includes conditions in an if section and actions in a run section. Conditions: Multiple conditions can be listed for a single automation, with AND relationship between the conditions, hence all listed conditions must pass to invoke the actions. The conditions are evaluated on new Pull Requests or changes to the Pull Request. Actions: Multiple actions can be listed in a single automation, the actions are invoked one by one. PRs that are marked as Draft are ignored by default, you can change that, see config . Schema The following sections are used in .cm file to describe the desired automations: manifest config automations manifest The first section in a gitstream.cm file is the manifest . manifest : version : 1.0 The only field required is version . Key Required Type Description manifest Y Map The manifest section root manifest.version Y String Specify the .cm spec version: 0.1, 1.0 The manifest version field is used to parse the .cm file, in the future if breaking changes are introduced to the parser then older automation will be still supported. config The config section is optional in the .cm file and is used to specify configuration for the way gitStream works. Key Type Default Scope Description config Map - per .cm file The config section, applies for the automations defined in the current file config.admin.users [String] [] gitstream.cm Admin user list (use the Git provider user names) config.ignore_files [String] [] per .cm file Exclude specific files config.ignore_repositories [String] [] per .cm file Exclude specific repositories config.user_mapping [String: String] [] per .cm file Key value list of Git user detailes and Git provider account names config.admin.users When specified in gitstream.cm the config.admin.users allows adding admin rights, when a PR changes the *.cm files only, if the user is listed in config.admin.users the PR will be then approved by gitStream. For example, setting popeye as admin: example config : admin : users : [ 'popeye' ] This configuration is valid only when used in .cm/gitstream.cm , when defined in other .cm files this configuration is ignored. config.ignore_files The config.ignore_files supports glob pattern matching that contains list of files to ignore, for example: example config : ignore_files : - 'yarn.lock' - 'package-lock.json' - 'openapi.json' - 'ui/src/**/*Model.d.ts' config.ignore_repositories The config.ignore_repositories contains list of repositories to ignore, for example: example config : ignore_repositories : - services - common For the listed repositories, the automation defined in the CM file shall not apply. config.user_mapping Accepts list of key value strings. For example, when using rankByGitBlame or explainRankByGitBlame Git users are mapped to their matching Git provider accounts based on the Git details. The automatic mapping can sometimes result with the wrong account or fail to find a proper mapping, in these cases you can configure the config.user_mapping . This allows you to map confusing Git user into their specific accounts and dump some irrelevant accounts: example config : user_mapping : - 'Popeye Man <popeye@invalid.com>' : 'popeye-the-salyor-man' - 'Popeye Man <popeye2@invalid.com>' : 'popeye-the-salyor-man' - 'Popeye' : null When using rankByGitBlame to assign reviewers automatically with add-reviewers@v1 then mapping users to null is a way to prevent the automatic mapping in certain cases, like in your example contributors that are not longer part of the team. On the other hand, when using explainRankByGitBlame with add-comment@v1 it still shows these users details in the PR comment suggestion as this info might be valuable by itself. - action : add-reviewers@v1 args : # (1) reviewers : {{ repo | rankByGitBlame ( gt = 25 ) }} - action : add-comment@v1 args : # (2) comment : | {{ repo | explainRankByGitBlame ( gt = 25 ) }} rankByGitBlame will drop null users explainRankByGitBlame will NOT drop null users automations The automations section defines the automations and their conditions. automations : mark_small_pr : if : - {{ checks.size.is.xsmall }} run : - action : add-label@v1 args : label : xsmall Each automation includes its name, and few fields: if and run . Key Required Type Description automations Y Map The automations section root automations.NAME Y Map User defined name of the automation, can be any string automations.NAME.if Y Map List of conditions with AND relationship automations.NAME.run Y Map Actions to run if all conditions are met, invoked one by one The if field includes the list of conditions. The conditions are checked when a pull request is opened or changed, if all the conditions pass, the automation is executed. The run field includes the automation to execute. It includes the following fields: Key Required Type Description action Y String The action pointer engine N String The action engine, default is gitstream args N List The action inputs list For gitstream engine, the action is specified by: name@version gitStream supported actions, see actions . Reusing checks You can define an accessory section, e.g. checks , that defines common conditions, and reuse. size : is : small : {{ branch.diff.size < 20 }} medium : {{ branch.diff.size >= 20 and branch.diff.size < 100 }} large : {{ branch.diff.size >= 100 }} automations : approve_small : if : - {{ size.is.small }} run : - action : approve@v1 mark_small_medium : if : # Check that the PR is either small or medium size - {{ size.is.small or size.is.medium }} # AND its less than 5 minutes review (estimated) - {{ branch | estimatedReviewTime <= 5 }} run : - action : add-label@v1 args : label : 'good-size'","title":"Configuration"},{"location":"cm-file/#overview","text":"Continuous Merge automation files have a .cm extension. In a repository, gitStream loads and parse the .cm directory, which can have multiple automation files, each of which is evaluated independently. You can edit the .cm files and add your own checks and rules. Check out the Automation examples .","title":"Overview"},{"location":"cm-file/#automation-rules","text":"There are two types of automation rules: repository level rules and organization level rules. Repository level rules are set by creating a special .cm directory in the repository root. Automation rules are specified in files in this directory, which can have any name but must end with .cm . Organization level rules are defined by creating a special repository named cm in the organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. When organization level rules are defines, repository level automation shall take precedence and override organization automation when having the same identifier. An autoamtion identifier is a compistion of the CM file name and the automation name. For example when safe_changes is defined in gitstream.cm then the automation identifier shall be gitstream/safe_changes Tip You can exclude certain repositoires per automation file using the config.ignore_repositories","title":"Automation rules"},{"location":"cm-file/#repository-automation-rules","text":"Repository automation rules are set by creating a special .cm directory in your repository root. Automation rules are specified in files in this directory, these files can have any name but ends with .cm . By default, you start with a single automation file .cm/gitstream.cm . Every file is parsed independently, and the parsing results are combined and executed. Specifically: Automation rules are allowed to have same name in different .cm files The config section is defined per .cm file (except config.admin ) Any accessory expression defined in each file scope, therefore cannot be reused in another file (but it can be duplicated) When configured correctly, your repository directory structure should look like that (for GitHub): Repsository automation rules . \u251c\u2500 .cm/ \u2502 \u2514\u2500 *.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml Note The .cm/gitstream.cm is special, as it allows for repository level configuration such as config.admin .","title":"Repository automation rules"},{"location":"cm-file/#organization-automation-rules","text":"Organization automation rules are defined by creating a special repository cm in your organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. When configured correctly, the cm repository directory structure should look like that (for GitHub): Repsository automation rules . \u251c\u2500 *.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml For each PR the following automation rules are applied: Repository level rules Organization level rules, unless with the same identifier as a repository level automation When organization level rules are defined, then the CI/CD will be executed on the cm repository on behalf of the PR repository.","title":"Organization automation rules"},{"location":"cm-file/#the-cm-automation-file","text":"","title":"The .cm automation file"},{"location":"cm-file/#context-variables","text":"gitStream includes a collection of variables called contexts. These variable has all the inputs you need to code your automation, including files names and paths, code that was changed or who did the change. See more here .","title":"Context variables"},{"location":"cm-file/#filter-functions","text":"Filter functions are essentially callable functions that can be applied to variables. They are called with a pipe operator | and can take arguments inside parentheses ( ) . The logic expressions are based on Jinja2 syntax, supported by Nunjucks library. See more about the Nunjucks built-in filters here , and about gitStream built-in filters here .","title":"Filter functions"},{"location":"cm-file/#automation-actions","text":"Specify the desired automations that are triggered when all conditions are met, read more here . Each automation includes conditions in an if section and actions in a run section. Conditions: Multiple conditions can be listed for a single automation, with AND relationship between the conditions, hence all listed conditions must pass to invoke the actions. The conditions are evaluated on new Pull Requests or changes to the Pull Request. Actions: Multiple actions can be listed in a single automation, the actions are invoked one by one. PRs that are marked as Draft are ignored by default, you can change that, see config .","title":"Automation actions"},{"location":"cm-file/#schema","text":"The following sections are used in .cm file to describe the desired automations: manifest config automations","title":"Schema"},{"location":"cm-file/#manifest","text":"The first section in a gitstream.cm file is the manifest . manifest : version : 1.0 The only field required is version . Key Required Type Description manifest Y Map The manifest section root manifest.version Y String Specify the .cm spec version: 0.1, 1.0 The manifest version field is used to parse the .cm file, in the future if breaking changes are introduced to the parser then older automation will be still supported.","title":"manifest"},{"location":"cm-file/#config","text":"The config section is optional in the .cm file and is used to specify configuration for the way gitStream works. Key Type Default Scope Description config Map - per .cm file The config section, applies for the automations defined in the current file config.admin.users [String] [] gitstream.cm Admin user list (use the Git provider user names) config.ignore_files [String] [] per .cm file Exclude specific files config.ignore_repositories [String] [] per .cm file Exclude specific repositories config.user_mapping [String: String] [] per .cm file Key value list of Git user detailes and Git provider account names","title":"config"},{"location":"cm-file/#configadminusers","text":"When specified in gitstream.cm the config.admin.users allows adding admin rights, when a PR changes the *.cm files only, if the user is listed in config.admin.users the PR will be then approved by gitStream. For example, setting popeye as admin: example config : admin : users : [ 'popeye' ] This configuration is valid only when used in .cm/gitstream.cm , when defined in other .cm files this configuration is ignored.","title":"config.admin.users"},{"location":"cm-file/#configignore_files","text":"The config.ignore_files supports glob pattern matching that contains list of files to ignore, for example: example config : ignore_files : - 'yarn.lock' - 'package-lock.json' - 'openapi.json' - 'ui/src/**/*Model.d.ts'","title":"config.ignore_files"},{"location":"cm-file/#configignore_repositories","text":"The config.ignore_repositories contains list of repositories to ignore, for example: example config : ignore_repositories : - services - common For the listed repositories, the automation defined in the CM file shall not apply.","title":"config.ignore_repositories"},{"location":"cm-file/#configuser_mapping","text":"Accepts list of key value strings. For example, when using rankByGitBlame or explainRankByGitBlame Git users are mapped to their matching Git provider accounts based on the Git details. The automatic mapping can sometimes result with the wrong account or fail to find a proper mapping, in these cases you can configure the config.user_mapping . This allows you to map confusing Git user into their specific accounts and dump some irrelevant accounts: example config : user_mapping : - 'Popeye Man <popeye@invalid.com>' : 'popeye-the-salyor-man' - 'Popeye Man <popeye2@invalid.com>' : 'popeye-the-salyor-man' - 'Popeye' : null When using rankByGitBlame to assign reviewers automatically with add-reviewers@v1 then mapping users to null is a way to prevent the automatic mapping in certain cases, like in your example contributors that are not longer part of the team. On the other hand, when using explainRankByGitBlame with add-comment@v1 it still shows these users details in the PR comment suggestion as this info might be valuable by itself. - action : add-reviewers@v1 args : # (1) reviewers : {{ repo | rankByGitBlame ( gt = 25 ) }} - action : add-comment@v1 args : # (2) comment : | {{ repo | explainRankByGitBlame ( gt = 25 ) }} rankByGitBlame will drop null users explainRankByGitBlame will NOT drop null users","title":"config.user_mapping"},{"location":"cm-file/#automations","text":"The automations section defines the automations and their conditions. automations : mark_small_pr : if : - {{ checks.size.is.xsmall }} run : - action : add-label@v1 args : label : xsmall Each automation includes its name, and few fields: if and run . Key Required Type Description automations Y Map The automations section root automations.NAME Y Map User defined name of the automation, can be any string automations.NAME.if Y Map List of conditions with AND relationship automations.NAME.run Y Map Actions to run if all conditions are met, invoked one by one The if field includes the list of conditions. The conditions are checked when a pull request is opened or changed, if all the conditions pass, the automation is executed. The run field includes the automation to execute. It includes the following fields: Key Required Type Description action Y String The action pointer engine N String The action engine, default is gitstream args N List The action inputs list For gitstream engine, the action is specified by: name@version gitStream supported actions, see actions .","title":"automations"},{"location":"cm-file/#reusing-checks","text":"You can define an accessory section, e.g. checks , that defines common conditions, and reuse. size : is : small : {{ branch.diff.size < 20 }} medium : {{ branch.diff.size >= 20 and branch.diff.size < 100 }} large : {{ branch.diff.size >= 100 }} automations : approve_small : if : - {{ size.is.small }} run : - action : approve@v1 mark_small_medium : if : # Check that the PR is either small or medium size - {{ size.is.small or size.is.medium }} # AND its less than 5 minutes review (estimated) - {{ branch | estimatedReviewTime <= 5 }} run : - action : add-label@v1 args : label : 'good-size'","title":"Reusing checks"},{"location":"cm-syntax/","text":"CM Syntax gitStream CM syntax defines a powerful and flexible language that enables users to write automation rules and customize their workflows. In this guide, we'll walk you through the basics of CM syntax and provide examples to help you get started. How to read the different sections? Every CM file must have a single automations section, which is where you define your automation rules. In this section, you can create dictionaries that specify the conditions and actions of your automation rules. You can name each automation rule as you desire, making it easy to keep track of different rules in your file. In the example below, safe_changes is an automation. You can name each automation rule as you desire. In the example below, safe_changes can have any other name you like as long as it is a valid YAML string. You can also define user defined accessory sections. These sections can contain common variables and expressions that you can use to simplify your automation rule syntax and reuse it in different rules within the same file. This can help make your automation rules more readable and maintainable. In the example below we have defined is.formatting , is.docs and is.tests . automations : safe_changes : # (1) if : - {{ is .formatting or is .docs or is .tests }} run : - action : add-label@v1 args : label : 'safe-changes' - action : approve@v1 is : #(2) formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} User defined string that used to name the automation rule User defined accessory section The is.formatting and the other terms in the line are not the actual expression, it is just a way to make the long expression shorter or reuse it. It actually refers to the section at the bottom of the example that has the actual expressions: is : formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} You can change the is or the keys below it (e.g. formatting ) to any word (except some reserved words) you like and use that in your expressions \u2013 much like variables\u2026 How to read an expression? We will explore how gitStream verifies that only documents have been modified by using the following expression: # The pipe symbol `|` functions like a Unix terminal pipe, # the expression can be interpreted as `allDocs(files)` {{ files | allDocs }} In this expression, the file is a context variable that holds the files' full path for all the changes in the PR. The function allDocs is defined here and return true when files extensions are: md , mkdown , txt , rst , except for requirements.txt . Using logic operators Following in this example to invert the logic you can use not - a reserved word that invert boolean results: {{ not ( is .formatting or is .docs or is .tests ) }} Reserved words gitStream reserved words: manifest config automations every filter includes map match nope reject some allDocs allImages allTests codeExperts estimatedReviewTime extensions explainCodeExperts explainRankByGitBlame isFirstCommit isFormattingChange matchDiffLines rankByGitActivity rankByGitBlame Nunjucks reserved words: e if for asyncEach asyncAll macro set extends block include import raw verbatim filter call abs batch capitalize center default dictsort dump escape first float forceescape groupby indent int join last length list lower nl2br random reject rejectattr replace reverse round safe select selectattr slice sort string striptags sum title trim truncate upper urlencode urlize wordcount Syntax highlighting You can add support for .cm in your code editor, see FAQ .","title":"The CM syntax"},{"location":"cm-syntax/#cm-syntax","text":"gitStream CM syntax defines a powerful and flexible language that enables users to write automation rules and customize their workflows. In this guide, we'll walk you through the basics of CM syntax and provide examples to help you get started.","title":"CM Syntax"},{"location":"cm-syntax/#how-to-read-the-different-sections","text":"Every CM file must have a single automations section, which is where you define your automation rules. In this section, you can create dictionaries that specify the conditions and actions of your automation rules. You can name each automation rule as you desire, making it easy to keep track of different rules in your file. In the example below, safe_changes is an automation. You can name each automation rule as you desire. In the example below, safe_changes can have any other name you like as long as it is a valid YAML string. You can also define user defined accessory sections. These sections can contain common variables and expressions that you can use to simplify your automation rule syntax and reuse it in different rules within the same file. This can help make your automation rules more readable and maintainable. In the example below we have defined is.formatting , is.docs and is.tests . automations : safe_changes : # (1) if : - {{ is .formatting or is .docs or is .tests }} run : - action : add-label@v1 args : label : 'safe-changes' - action : approve@v1 is : #(2) formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} User defined string that used to name the automation rule User defined accessory section The is.formatting and the other terms in the line are not the actual expression, it is just a way to make the long expression shorter or reuse it. It actually refers to the section at the bottom of the example that has the actual expressions: is : formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} You can change the is or the keys below it (e.g. formatting ) to any word (except some reserved words) you like and use that in your expressions \u2013 much like variables\u2026","title":"How to read the different sections?"},{"location":"cm-syntax/#how-to-read-an-expression","text":"We will explore how gitStream verifies that only documents have been modified by using the following expression: # The pipe symbol `|` functions like a Unix terminal pipe, # the expression can be interpreted as `allDocs(files)` {{ files | allDocs }} In this expression, the file is a context variable that holds the files' full path for all the changes in the PR. The function allDocs is defined here and return true when files extensions are: md , mkdown , txt , rst , except for requirements.txt .","title":"How to read an expression?"},{"location":"cm-syntax/#using-logic-operators","text":"Following in this example to invert the logic you can use not - a reserved word that invert boolean results: {{ not ( is .formatting or is .docs or is .tests ) }}","title":"Using logic operators"},{"location":"cm-syntax/#reserved-words","text":"gitStream reserved words: manifest config automations every filter includes map match nope reject some allDocs allImages allTests codeExperts estimatedReviewTime extensions explainCodeExperts explainRankByGitBlame isFirstCommit isFormattingChange matchDiffLines rankByGitActivity rankByGitBlame Nunjucks reserved words: e if for asyncEach asyncAll macro set extends block include import raw verbatim filter call abs batch capitalize center default dictsort dump escape first float forceescape groupby indent int join last length list lower nl2br random reject rejectattr replace reverse round safe select selectattr slice sort string striptags sum title trim truncate upper urlencode urlize wordcount","title":"Reserved words"},{"location":"cm-syntax/#syntax-highlighting","text":"You can add support for .cm in your code editor, see FAQ .","title":"Syntax highlighting"},{"location":"context-variables/","text":"Context variables Context variable are the inputs for the automation conditions or checks. Note Items marked with are under development and are not available yet. Overview Context gitStream includes a collection of variables called contexts. branch files source repo pr Structures The following structures are used in the context objects: GitBlame Check Contributor FileDiff FileMetadata GeneralComment LineComment Example of a context object Partial example of a context object for a PR that changed few lines in a README.md file: { \"branch\" : { \"name\" : \"new-feature-branch\" , \"base\" : \"main\" , \"diff\" : { \"size\" : 50 , \"files_metadata\" : [ { \"original_file\" : \"README.md\" , \"new_file\" : \"README.md\" , \"deletions\" : 0 , \"additions\" : 2 } ] }, \"num_of_commits\" : 1 }, \"source\" : { \"diff\" : { \"files\" : [ { \"original_file\" : \"README.md\" , \"new_file\" : \"README.md\" , \"diff\" : \"@@ -10,3 +10,5 @@ This project \\n+\\n+## Intro\" , \"original_content\" : \"This project \\n\" , \"new_content\" : \"This project \\n\\n## Intro\" } ] } }, \"repo\" : { \"contributors\" : { \"popeye\" : \"46\" , \"olive\" : \"6\" } }, \"files\" : [ \"README.md\" ] } Reference branch The branch context contains info regarding the branch changes compared to the base branch. Note compared to the source context does not include actual source code. Values Type Description branch Map Includes the info related to the current branch branch.author String The branch author (the user that did first commit in the branch). The formatted like author in git-log , e.g. Popeye <popeye@acme.com> branch.author_name String The branch author name branch.author_email String The branch author email branch.base String The main branch, main branch.commits.messages [String] A list with all the commit messages in this branch branch.diff.size Integer The sum of line changed: additions, edits and deletions branch.diff.files_metadata FileMetadata List of changed files including their relative path branch.name String The current branch, feature-123-branch branch.num_of_commits Integer The number of commits in the branch The branch context doesn't include any source code, but only related metadata. Example for using branch.name and branch.author to automatically approve and merge version bumps. automations : dependabot : if : - {{ branch.name | includes ( term = \"dependabot\" ) }} - {{ branch.author | includes ( term = \"dependabot\" ) }} run : - action : approve@v1 - action : add-label@v1 args : label : \"approved-dependabot\" - action : merge@v1 args : wait_for_all_checks : true squash_on_merge : true files The files context includes the list of changed files in the branch compared to the main branch. Values Type Description files [String] List of all changed files with their full path For example, a typical files context can look like this: [ \"README.md\" , \"package.json\" , \"src/app.js\" , \"src/index.js\" , \"docs/examples.md\" ] Example for checking if certain changes are made: automations : ui_review : if : - {{ files | match ( list = ui_templates_files ) | some }} run : - action : add-reviewers@v1 args : reviewers : [ GitHubUser1 , GitHubUser2 ] ui_templates_files : - resources/app/ui_template.yml - resources/app/role_template.yml - resources/app/account_template.yml pr The pr context includes metadata related to the pull request. Values Type Description pr Map Includes the info related to the PR pr.approvals [String] The of reviewers that approved the PR pr.author String The PR author name pr.author_teams String The teams which the PR author is member of pr.checks Check List of checks, names and status pr.created_at String The date and time the PR was created pr.draft Bool true when the PR is marked as Draft/WIP pr.description String The PR description text pr.general_comments GeneralComment TBD pr.labels [String] The labels that are attached to the PR pr.line_comments LineComment TBD pr.provider String The Git cloud provider name, e.g. GitHub , GitLab etc. pr.reviewers [String] The list of reviewers set for this PR pr.status String The PR status: open , requested-changes , approved , merged pr.target String The branch the PR is intended merged into pr.title String The PR title pr.updated_at String The date and time the PR was last updated Example for checking the PR title includes a Jira ticket: automations : check_jira_ticket : if : - {{ not has.jira_ticket }} run : - action : add-label@v1 args : label : \"missing-ticket\" color : 'F6443B' has : jira_ticket : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 20 ,} $ /) }} repo The repo context includes metadata related to the repo. Values Type Description repo Map Includes the info related to the current repo repo.git_activity GitActivity Per file and user, the number of lines changed every week for the last 52 weeks repo.age Integer Number of days since first commit (of any user) repo.author_age Integer number of days since first commit to this repo repo.blame GitBlame The percentage each user's lines in a file, the list includes all changed files in the branch. The list is sorted by the ratio field repo.contributors Contributor List of contributors in the repo repo.name String Repository name source The source context includes a list of FileDiff objects that can be used to get insights based on code changes. The changes compared to the latest main branch. Values Type Description source.diff.files FileDiff List of changed files with their code changes The source context include all code changes, it is not safe to share it with unknown services. Check structure Coming soon { \"name\" : S tr i n g , # The check na me \"status\" : S tr i n g , # The check s tatus : `queued` , `i n _progress` , `comple te d` \"conclusion\" : S tr i n g , # The check co n clusio n : `ac t io n _required` , `ca n celled` , ` fa ilure` ` neutral ` , `success` , `skipped` , `s tale ` , ` t imed_ou t ` } Contributor structure The repo.contributors mapping includes a list of Contributor , where the user name is used as dynamic key: { USER_NAME : I nte ger # Number o f commi ts } FileDiff structure The source.diff.files mapping includes a list of FileDiff : { \"diff\" : S tr i n g , # The co ntent i n di ff f orma t `+` f or addi t io ns , ` - ` f or dele t io ns \"new_content\" : S tr i n g , # The ne w co ntent i n t his bra n ch \"new_file\" : S tr i n g , # The na me o f t he f ile a fter t he cha n ges , i n cludi n g i ts pa t h \"original_content\" : S tr i n g , # The co ntent as is i n t he `mai n ` bra n ch \"original_file\" : S tr i n g , # The na me o f t he f ile be f ore t he cha n ges , i n cludi n g i ts pa t h } FileMetadata structure The branch.diff.files_metadata mapping includes a list of FileMetadata : { \"additions\" : I nte ger , # The nu mber o f li nes edi te d or added t o t he f ile \"deletions\" : I nte ger , # The nu mber o f li nes removed fr om t he f ile \"file\" : S tr i n g , # The na me o f t he f ile be f ore t he cha n ges , i n cludi n g i ts pa t h } For example, sum additions in javascript code files: {{ branch.diff.files_metadata | filter ( attr = 'new_file' , regex = r / \\ .js $|\\ .ts $ /) | map ( attr = 'additions' ) | sum }} GeneralComment structure { \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"updated_at\" : S tr i n g , # The t ime o n which t he comme nt was las t upda te d \"state\" : S tr i n g , # ei t her 'CHANGES_REQUESTED' , 'COMMENT' , 'APPROVE' or 'PENDING' } GitActivity structure This structure include per changed file, for every user, the number of lines changed every week for the last 52 weeks. { FILE_NAME : # The f ile na me a n d pa t h { # The gi t user ide nt i f ier (S tr i n g) GIT_USER : { \"week_INDEX\" : I nte ger # Number o f li nes cha n ged t ha t week # ... f or t he las t 52 weeks } } } For example: { \"src/utils/service.js\" : { \"popeye <popeye@acme.com>\" : { \"week_1\" : 20 , \"week_2\" : 15 , \"week_10\" : 250 }, \"olive <olive@acme.com>\" : { \"week_1\" : 3 , \"week_3\" : 50 , \"week_52\" : 250 } }, \"README.md\" : { \"popeye <popeye@acme.com>\" : { \"week_2\" : 15 , \"week_3\" : 10 } } } GitBlame structure For each file, a list of user's blame ratio. { FILE_NAME : # The f ile na me a n d pa t h { # The gi t user ide nt i f ier (S tr i n g) GIT_USER : I nte ger , # Prece nta ge 0-100 , ra t io o f user's li nes / t o tal li nes i n f ile } } For example: { \"src/utils/service.js\" : { \"popeye <popeye@acme.com>\" : 78 , \"olive <olive@acme.com>\" : 22 , }, \"README.md\" : { \"popeye <popeye@acme.com>\" : 13 , \"olive <olive@acme.com>\" : 22 , \"brutus <brutus@acme.com>\" : 65 , } } LineComment structure { \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"updated_at\" : S tr i n g , # The t ime o n which t he comme nt was upda te d \"start_line\" : I nte ger , # The f irs t li ne marked f or t his comme nt \"end_line\" : I nte ger , # The las t li ne marked f or t his comme nt }","title":"Context variables"},{"location":"context-variables/#context-variables","text":"Context variable are the inputs for the automation conditions or checks. Note Items marked with are under development and are not available yet.","title":"Context variables"},{"location":"context-variables/#overview","text":"","title":"Overview"},{"location":"context-variables/#context","text":"gitStream includes a collection of variables called contexts. branch files source repo pr","title":"Context"},{"location":"context-variables/#structures","text":"The following structures are used in the context objects: GitBlame Check Contributor FileDiff FileMetadata GeneralComment LineComment Example of a context object Partial example of a context object for a PR that changed few lines in a README.md file: { \"branch\" : { \"name\" : \"new-feature-branch\" , \"base\" : \"main\" , \"diff\" : { \"size\" : 50 , \"files_metadata\" : [ { \"original_file\" : \"README.md\" , \"new_file\" : \"README.md\" , \"deletions\" : 0 , \"additions\" : 2 } ] }, \"num_of_commits\" : 1 }, \"source\" : { \"diff\" : { \"files\" : [ { \"original_file\" : \"README.md\" , \"new_file\" : \"README.md\" , \"diff\" : \"@@ -10,3 +10,5 @@ This project \\n+\\n+## Intro\" , \"original_content\" : \"This project \\n\" , \"new_content\" : \"This project \\n\\n## Intro\" } ] } }, \"repo\" : { \"contributors\" : { \"popeye\" : \"46\" , \"olive\" : \"6\" } }, \"files\" : [ \"README.md\" ] }","title":"Structures"},{"location":"context-variables/#reference","text":"","title":"Reference"},{"location":"context-variables/#branch","text":"The branch context contains info regarding the branch changes compared to the base branch. Note compared to the source context does not include actual source code. Values Type Description branch Map Includes the info related to the current branch branch.author String The branch author (the user that did first commit in the branch). The formatted like author in git-log , e.g. Popeye <popeye@acme.com> branch.author_name String The branch author name branch.author_email String The branch author email branch.base String The main branch, main branch.commits.messages [String] A list with all the commit messages in this branch branch.diff.size Integer The sum of line changed: additions, edits and deletions branch.diff.files_metadata FileMetadata List of changed files including their relative path branch.name String The current branch, feature-123-branch branch.num_of_commits Integer The number of commits in the branch The branch context doesn't include any source code, but only related metadata. Example for using branch.name and branch.author to automatically approve and merge version bumps. automations : dependabot : if : - {{ branch.name | includes ( term = \"dependabot\" ) }} - {{ branch.author | includes ( term = \"dependabot\" ) }} run : - action : approve@v1 - action : add-label@v1 args : label : \"approved-dependabot\" - action : merge@v1 args : wait_for_all_checks : true squash_on_merge : true","title":"branch"},{"location":"context-variables/#files","text":"The files context includes the list of changed files in the branch compared to the main branch. Values Type Description files [String] List of all changed files with their full path For example, a typical files context can look like this: [ \"README.md\" , \"package.json\" , \"src/app.js\" , \"src/index.js\" , \"docs/examples.md\" ] Example for checking if certain changes are made: automations : ui_review : if : - {{ files | match ( list = ui_templates_files ) | some }} run : - action : add-reviewers@v1 args : reviewers : [ GitHubUser1 , GitHubUser2 ] ui_templates_files : - resources/app/ui_template.yml - resources/app/role_template.yml - resources/app/account_template.yml","title":"files"},{"location":"context-variables/#pr","text":"The pr context includes metadata related to the pull request. Values Type Description pr Map Includes the info related to the PR pr.approvals [String] The of reviewers that approved the PR pr.author String The PR author name pr.author_teams String The teams which the PR author is member of pr.checks Check List of checks, names and status pr.created_at String The date and time the PR was created pr.draft Bool true when the PR is marked as Draft/WIP pr.description String The PR description text pr.general_comments GeneralComment TBD pr.labels [String] The labels that are attached to the PR pr.line_comments LineComment TBD pr.provider String The Git cloud provider name, e.g. GitHub , GitLab etc. pr.reviewers [String] The list of reviewers set for this PR pr.status String The PR status: open , requested-changes , approved , merged pr.target String The branch the PR is intended merged into pr.title String The PR title pr.updated_at String The date and time the PR was last updated Example for checking the PR title includes a Jira ticket: automations : check_jira_ticket : if : - {{ not has.jira_ticket }} run : - action : add-label@v1 args : label : \"missing-ticket\" color : 'F6443B' has : jira_ticket : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 20 ,} $ /) }}","title":"pr"},{"location":"context-variables/#repo","text":"The repo context includes metadata related to the repo. Values Type Description repo Map Includes the info related to the current repo repo.git_activity GitActivity Per file and user, the number of lines changed every week for the last 52 weeks repo.age Integer Number of days since first commit (of any user) repo.author_age Integer number of days since first commit to this repo repo.blame GitBlame The percentage each user's lines in a file, the list includes all changed files in the branch. The list is sorted by the ratio field repo.contributors Contributor List of contributors in the repo repo.name String Repository name","title":"repo"},{"location":"context-variables/#source","text":"The source context includes a list of FileDiff objects that can be used to get insights based on code changes. The changes compared to the latest main branch. Values Type Description source.diff.files FileDiff List of changed files with their code changes The source context include all code changes, it is not safe to share it with unknown services.","title":"source"},{"location":"context-variables/#check-structure","text":"Coming soon { \"name\" : S tr i n g , # The check na me \"status\" : S tr i n g , # The check s tatus : `queued` , `i n _progress` , `comple te d` \"conclusion\" : S tr i n g , # The check co n clusio n : `ac t io n _required` , `ca n celled` , ` fa ilure` ` neutral ` , `success` , `skipped` , `s tale ` , ` t imed_ou t ` }","title":"Check structure"},{"location":"context-variables/#contributor-structure","text":"The repo.contributors mapping includes a list of Contributor , where the user name is used as dynamic key: { USER_NAME : I nte ger # Number o f commi ts }","title":"Contributor structure"},{"location":"context-variables/#filediff-structure","text":"The source.diff.files mapping includes a list of FileDiff : { \"diff\" : S tr i n g , # The co ntent i n di ff f orma t `+` f or addi t io ns , ` - ` f or dele t io ns \"new_content\" : S tr i n g , # The ne w co ntent i n t his bra n ch \"new_file\" : S tr i n g , # The na me o f t he f ile a fter t he cha n ges , i n cludi n g i ts pa t h \"original_content\" : S tr i n g , # The co ntent as is i n t he `mai n ` bra n ch \"original_file\" : S tr i n g , # The na me o f t he f ile be f ore t he cha n ges , i n cludi n g i ts pa t h }","title":"FileDiff structure"},{"location":"context-variables/#filemetadata-structure","text":"The branch.diff.files_metadata mapping includes a list of FileMetadata : { \"additions\" : I nte ger , # The nu mber o f li nes edi te d or added t o t he f ile \"deletions\" : I nte ger , # The nu mber o f li nes removed fr om t he f ile \"file\" : S tr i n g , # The na me o f t he f ile be f ore t he cha n ges , i n cludi n g i ts pa t h } For example, sum additions in javascript code files: {{ branch.diff.files_metadata | filter ( attr = 'new_file' , regex = r / \\ .js $|\\ .ts $ /) | map ( attr = 'additions' ) | sum }}","title":"FileMetadata structure"},{"location":"context-variables/#generalcomment-structure","text":"{ \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"updated_at\" : S tr i n g , # The t ime o n which t he comme nt was las t upda te d \"state\" : S tr i n g , # ei t her 'CHANGES_REQUESTED' , 'COMMENT' , 'APPROVE' or 'PENDING' }","title":"GeneralComment structure"},{"location":"context-variables/#gitactivity-structure","text":"This structure include per changed file, for every user, the number of lines changed every week for the last 52 weeks. { FILE_NAME : # The f ile na me a n d pa t h { # The gi t user ide nt i f ier (S tr i n g) GIT_USER : { \"week_INDEX\" : I nte ger # Number o f li nes cha n ged t ha t week # ... f or t he las t 52 weeks } } } For example: { \"src/utils/service.js\" : { \"popeye <popeye@acme.com>\" : { \"week_1\" : 20 , \"week_2\" : 15 , \"week_10\" : 250 }, \"olive <olive@acme.com>\" : { \"week_1\" : 3 , \"week_3\" : 50 , \"week_52\" : 250 } }, \"README.md\" : { \"popeye <popeye@acme.com>\" : { \"week_2\" : 15 , \"week_3\" : 10 } } }","title":"GitActivity structure"},{"location":"context-variables/#gitblame-structure","text":"For each file, a list of user's blame ratio. { FILE_NAME : # The f ile na me a n d pa t h { # The gi t user ide nt i f ier (S tr i n g) GIT_USER : I nte ger , # Prece nta ge 0-100 , ra t io o f user's li nes / t o tal li nes i n f ile } } For example: { \"src/utils/service.js\" : { \"popeye <popeye@acme.com>\" : 78 , \"olive <olive@acme.com>\" : 22 , }, \"README.md\" : { \"popeye <popeye@acme.com>\" : 13 , \"olive <olive@acme.com>\" : 22 , \"brutus <brutus@acme.com>\" : 65 , } }","title":"GitBlame structure"},{"location":"context-variables/#linecomment-structure","text":"{ \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"updated_at\" : S tr i n g , # The t ime o n which t he comme nt was upda te d \"start_line\" : I nte ger , # The f irs t li ne marked f or t his comme nt \"end_line\" : I nte ger , # The las t li ne marked f or t his comme nt }","title":"LineComment structure"},{"location":"custom-filters/","text":"Custom filters Custom filters are implemented in JavaScript. Attention Coming soon You can add custom filters by editing the .cm/filters.js file in your repo. . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm \u2502 \u2514\u2500 filters.js Adding filters Filters can have input arguments and return a result which can be any valid JavaScript type. An example for a .cm/filters.js : export default { // The includes() method determines whether an array includes a // certain value among its entries, returning true or false. myIncludes : ( list , term ) => { return list . includes ( term ); }, // Determine if a number is even or odd isOdd : ( n ) => { return parseInt ( n ) % 2 == 0 ; } } Once filters are added it can be used in the .cm files, for example using isOdd filter looks like this: {{ branch.diff.size | isOdd }} Using npm packages The file is loaded by a node.js runtime, the following packages are pre installed and can be imported and used: child_process Using external tools results Tip: cache result to local file system and reuse in CI/CD const { exec } = require ( 'child_process' ); exec ( 'npm run test | wc -l' , ( err , stdout , stderr ) => { if ( err ) { // node couldn't execute the command return ; } // the *entire* stdout and stderr (buffered) console . log ( `stdout: ${ stdout } ` ); console . log ( `stderr: ${ stderr } ` ); return 123 ; }); For example: # access coverage results coverage : is : # npm run test -> /file/here enough : {{ source | my_coverage > 80 }} # 2 user's filter","title":"Custom filters"},{"location":"custom-filters/#custom-filters","text":"Custom filters are implemented in JavaScript. Attention Coming soon You can add custom filters by editing the .cm/filters.js file in your repo. . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm \u2502 \u2514\u2500 filters.js","title":"Custom filters"},{"location":"custom-filters/#adding-filters","text":"Filters can have input arguments and return a result which can be any valid JavaScript type. An example for a .cm/filters.js : export default { // The includes() method determines whether an array includes a // certain value among its entries, returning true or false. myIncludes : ( list , term ) => { return list . includes ( term ); }, // Determine if a number is even or odd isOdd : ( n ) => { return parseInt ( n ) % 2 == 0 ; } } Once filters are added it can be used in the .cm files, for example using isOdd filter looks like this: {{ branch.diff.size | isOdd }}","title":"Adding filters"},{"location":"custom-filters/#using-npm-packages","text":"The file is loaded by a node.js runtime, the following packages are pre installed and can be imported and used: child_process","title":"Using npm packages"},{"location":"custom-filters/#using-external-tools-results","text":"Tip: cache result to local file system and reuse in CI/CD const { exec } = require ( 'child_process' ); exec ( 'npm run test | wc -l' , ( err , stdout , stderr ) => { if ( err ) { // node couldn't execute the command return ; } // the *entire* stdout and stderr (buffered) console . log ( `stdout: ${ stdout } ` ); console . log ( `stderr: ${ stderr } ` ); return 123 ; }); For example: # access coverage results coverage : is : # npm run test -> /file/here enough : {{ source | my_coverage > 80 }} # 2 user's filter","title":"Using external tools results"},{"location":"dry-run-mode/","text":"Dry-run mode gitStream runs automations as described in .cm/*.cm in the main branch. To allow testing and experimenting with new rules, gitStream supports dry-run mode. When you commit changes to .cm/*.cm in a PR branch, gitStream will switch to dry-run mode . In dry-run mode gitStream will stop executing automation rules described in the main branch for this PR, instead gitStream will parse the automation rules described in the .cm/*.cm of the PR branch and add a comment in the PR that describes all the automations actions \u2013 without executing the actions. Note When in dry-run mode, changes to the .cm/*.cm file are ignored when calculating the conditions to help focus on setting the right automations Once you are satisfied with the results, you can merge the .cm/*.cm into the main branch to enable all new changes.","title":"Dry-run mode"},{"location":"dry-run-mode/#dry-run-mode","text":"gitStream runs automations as described in .cm/*.cm in the main branch. To allow testing and experimenting with new rules, gitStream supports dry-run mode. When you commit changes to .cm/*.cm in a PR branch, gitStream will switch to dry-run mode . In dry-run mode gitStream will stop executing automation rules described in the main branch for this PR, instead gitStream will parse the automation rules described in the .cm/*.cm of the PR branch and add a comment in the PR that describes all the automations actions \u2013 without executing the actions. Note When in dry-run mode, changes to the .cm/*.cm file are ignored when calculating the conditions to help focus on setting the right automations Once you are satisfied with the results, you can merge the .cm/*.cm into the main branch to enable all new changes.","title":"Dry-run mode"},{"location":"examples/","text":"Examples Here are some examples of actions that can be applied on repositories by gitStream. Tip See full list on the gitStream repository . Review Efficiency Label PRs by complexity Automatically add a color-coded label to PRs with the estimated review time. When used, each PR will be annotated with this label. When there are new commits to the PR, gitStream manage the label and replace it with an updated review time when needed. automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # To simplify the automation, this calculation is placed under a unique YAML key. # The result is assigned to `calc.etr` which is used in the automation above. # You can add as many keys as you like. calc : etr : {{ branch | estimatedReviewTime }} Download and add to your repo .cm directory Approve safe changes PRs that include only documentation changes are verified and approved by gitStream. In the example below, marked in yellow, the files context is checked by allDocs filter that verifies there are only document files. PRs that pass the check are approved by gitStream. Check out the functions to learn more: isFormattingChange allDocs allTests allImages automations : safe_changes : if : - {{ is .formatting or is .docs or is .tests or is .asset }} run : - action : add-label@v1 args : label : 'safe-changes' - action : approve@v1 # To simplify the automation, this calculation is placed under a unique YAML key. # The result is is assigned to `is.formatting`, `is.docs` and `is.tests` which is # used in the automation above. You can add as many keys as you like. is : formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} asset : {{ files | match ( regex = r / \\. ( png | svg | gif | css ) $ /) | every }} Download and add to your repo .cm directory Review Quality Like CODEOWNERS but better With gitStream you can define your sensitive areas, set reviewers, while allowing faster merge time for non-sensitive changes. The nope filter is used to make sure no change is in a sensitive file. Tip You can also use regex instead of normal strings, see here automations : approve_non_sensitive : if : - {{ files | match ( list = sensitive ) | nope }} run : - action : add-label@v1 args : label : 'non-sensitive' color : '#2CA44E' - action : approve@v1 require_review : if : - {{ files | match ( list = sensitive ) | some }} run : - action : add-reviewers@v1 args : reviewers : [ acme/a-team ] - action : set-required-approvals@v1 args : approvals : 1 sensitive : - src/app/auth/ - src/app/routing/ - src/app/resources/ Download and add to your repo .cm directory Review PRs with Code Experts Not every review is equal, getting the right one is important to get high quality feedback. Overall, selecting the right reviewer for your pull request is crucial to ensure that your changes are thoroughly reviewed and that any issues are identified and addressed before they are merged into the main codebase. The codeExperts filter ( learn more here ) can help simplify this process by highlighting the most qualified contributors based on their activity in the relevant code area. automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Download and add to your repo .cm directory Using explainCodeExperts shows the resulting data in the PR comment. Last, the codeExperts assigns the code experts to review the PR automatically. You can read more on both in the function filter page . Mark PRs without tests PRs that don't have tests changes can be marked automatically. When a PR is opened without any tests, this label is added: Once the tests are added and committed, gitStream automatically removes the label: automations : no_tests : if : - {{ files | match ( regex = r /[ ^ a-zA-Z0-9 ]( spec | test | tests )[ ^ a-zA-Z0-9 ]/) | nope }} run : - action : add-label@v1 args : label : 'missing-tests' color : '#E94637' Download and add to your repo .cm directory Require 2 approvals for complex PRs Automatically require 2 reviewers for PRs that have more than 100 lines of code changed under the src directory. This ability can be very useful if you want to have more approvals for certain PRs, but rather than increasing the required approvals for all PRs using GitHub repo settings, it allows doing that only for specific PRs. Multiple conditions in the if section has AND relationship and must all be true for the automation to execute. automations : double_review : if : - {{ branch | estimatedReviewTime >= 30 }} - {{ files | length >= 10 }} - {{ files | match ( regex = r / src \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2 Download and add to your repo .cm directory Note gitStream should be set as required check in the repo so it can block merge Share knowledge When setting lt to 50, which stands for the less-than sign : < , only those who contributed less than 50% of lines overall are selected. Applying random will pick one from the list. automations : share_knowledge : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | rankByGitBlame ( lt = 50 ) | random }} Download and add to your repo .cm directory Mark PRs with deleted files When files are removed entirely you want to be sure it is not by accident, mark these PRs. automations : deleted : if : - {{ has.deleted_files }} run : - action : add-label@v1 args : label : 'deleted-files' color : '#DF9C04' has : deleted_files : {{ source.diff.files | map ( attr = 'new_file' ) | match ( term = '/dev/null' ) | some }} Download and add to your repo .cm directory Review Policy Close PRs when touching out-of-scope files This action, once triggered, close the PR without merging. You can also replace close with requested-changes to leave the PR open but request to undo the UI changes. automations : close_ui_changes_by_non_ui : if : - {{ files | match ( regex = r / src \\ / views /) | some }} - {{ pr.author_teams | match ( term = 'ui-team' ) | nope }} run : - action : add-comment@v1 args : comment : | Please contact a member of `ui-team` team if you need to make changes to files in `src/views` - action : close@v1 Download and add to your repo .cm directory Assign mentors to new contributors During the first 21 days, a contributor is assigned automatically to get reviews by specific people. By changing 21 you can add or reduce the amount of time. Make sure to change the reviewers according to your team members. automations : junior : if : - {{ repo.author_age < 21 and ( repo.age - repo.author_age ) >= 21 }} run : - action : add-label@v1 args : label : 'first-weeks' color : '#FBBD10' - action : add-comment@v1 args : comment : | During your first 21 days, your team lead will be assigned to review your PRs. - action : add-reviewers@v1 args : reviewers : [ popeye ] Download and add to your repo .cm directory Validate new component has required field You can define required fields for components, so when your team members adds new components they should also add the required field, description in the example below. automations : catch_deprecated_components : if : - {{ source.diff.files | matchDiffLines ( regex = r / LambdaFunction /) | some }} - {{ source.diff.files | matchDiffLines ( regex = r / description :/) | nope }} run : - action : add-label@v1 args : label : 'lambda-missing-field' color : '#FF0000' - action : request-changes@v1 args : comment : | New `LambdaFunction` must have `description:` field. Request changes on deprecated APIs For example, assume we have an old API callElvis we want to switch from to a new API callGaga , gitStream can review and trigger a change request automatically when the PR includes use of the deprecated API. This pattern allows defining best practices in .cm code. automations : catch_deprecated_components : if : - {{ source.diff.files | matchDiffLines ( regex = r / callElvis /) | some }} run : - action : add-label@v1 args : label : 'deprecated-component' color : '#FF0000' - action : request-changes@v1 args : comment : | you have used deprecated API, use `callingGaga` instead gitStream supports iterators over arrays and dictionaries, so you can also make it more general: automations : {% for item in deprecated %} # Automation names should be unique, therefore the iteration number postfix catch_deprecated_components_ {{ loop .index }} : if : - {{ source.diff.files | matchDiffLines ( regex = item.regex ) | some }} run : - action : add-label@v1 args : label : 'deprecated-component' color : '#FF0000' - action : request-changes@v1 args : comment : | ` {{ item.old }} ` component is deprecated, use ` {{ item.new }} ` instead {% endfor %} # This list includes the deprecated items deprecated : - regex : r/callElvis/ old : Elvis new : Gaga - regex : r/callOldAPI/ old : callOldAPI new : callBetterAPI Download and add to your repo .cm directory More examples More examples can be found in the gitStream repository . Tip You can boost your GitHub reputation with your new automation rule - open a PR and add it to the gitStream repository","title":"Examples"},{"location":"examples/#examples","text":"Here are some examples of actions that can be applied on repositories by gitStream. Tip See full list on the gitStream repository .","title":"Examples"},{"location":"examples/#review-efficiency","text":"","title":"Review Efficiency"},{"location":"examples/#label-prs-by-complexity","text":"Automatically add a color-coded label to PRs with the estimated review time. When used, each PR will be annotated with this label. When there are new commits to the PR, gitStream manage the label and replace it with an updated review time when needed. automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # To simplify the automation, this calculation is placed under a unique YAML key. # The result is assigned to `calc.etr` which is used in the automation above. # You can add as many keys as you like. calc : etr : {{ branch | estimatedReviewTime }} Download and add to your repo .cm directory","title":"Label PRs by complexity"},{"location":"examples/#approve-safe-changes","text":"PRs that include only documentation changes are verified and approved by gitStream. In the example below, marked in yellow, the files context is checked by allDocs filter that verifies there are only document files. PRs that pass the check are approved by gitStream. Check out the functions to learn more: isFormattingChange allDocs allTests allImages automations : safe_changes : if : - {{ is .formatting or is .docs or is .tests or is .asset }} run : - action : add-label@v1 args : label : 'safe-changes' - action : approve@v1 # To simplify the automation, this calculation is placed under a unique YAML key. # The result is is assigned to `is.formatting`, `is.docs` and `is.tests` which is # used in the automation above. You can add as many keys as you like. is : formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} asset : {{ files | match ( regex = r / \\. ( png | svg | gif | css ) $ /) | every }} Download and add to your repo .cm directory","title":"Approve safe changes"},{"location":"examples/#review-quality","text":"","title":"Review Quality"},{"location":"examples/#like-codeowners-but-better","text":"With gitStream you can define your sensitive areas, set reviewers, while allowing faster merge time for non-sensitive changes. The nope filter is used to make sure no change is in a sensitive file. Tip You can also use regex instead of normal strings, see here automations : approve_non_sensitive : if : - {{ files | match ( list = sensitive ) | nope }} run : - action : add-label@v1 args : label : 'non-sensitive' color : '#2CA44E' - action : approve@v1 require_review : if : - {{ files | match ( list = sensitive ) | some }} run : - action : add-reviewers@v1 args : reviewers : [ acme/a-team ] - action : set-required-approvals@v1 args : approvals : 1 sensitive : - src/app/auth/ - src/app/routing/ - src/app/resources/ Download and add to your repo .cm directory","title":"Like CODEOWNERS but better"},{"location":"examples/#review-prs-with-code-experts","text":"Not every review is equal, getting the right one is important to get high quality feedback. Overall, selecting the right reviewer for your pull request is crucial to ensure that your changes are thoroughly reviewed and that any issues are identified and addressed before they are merged into the main codebase. The codeExperts filter ( learn more here ) can help simplify this process by highlighting the most qualified contributors based on their activity in the relevant code area. automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Download and add to your repo .cm directory Using explainCodeExperts shows the resulting data in the PR comment. Last, the codeExperts assigns the code experts to review the PR automatically. You can read more on both in the function filter page .","title":"Review PRs with Code Experts"},{"location":"examples/#mark-prs-without-tests","text":"PRs that don't have tests changes can be marked automatically. When a PR is opened without any tests, this label is added: Once the tests are added and committed, gitStream automatically removes the label: automations : no_tests : if : - {{ files | match ( regex = r /[ ^ a-zA-Z0-9 ]( spec | test | tests )[ ^ a-zA-Z0-9 ]/) | nope }} run : - action : add-label@v1 args : label : 'missing-tests' color : '#E94637' Download and add to your repo .cm directory","title":"Mark PRs without tests"},{"location":"examples/#require-2-approvals-for-complex-prs","text":"Automatically require 2 reviewers for PRs that have more than 100 lines of code changed under the src directory. This ability can be very useful if you want to have more approvals for certain PRs, but rather than increasing the required approvals for all PRs using GitHub repo settings, it allows doing that only for specific PRs. Multiple conditions in the if section has AND relationship and must all be true for the automation to execute. automations : double_review : if : - {{ branch | estimatedReviewTime >= 30 }} - {{ files | length >= 10 }} - {{ files | match ( regex = r / src \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2 Download and add to your repo .cm directory Note gitStream should be set as required check in the repo so it can block merge","title":"Require 2 approvals for complex PRs"},{"location":"examples/#share-knowledge","text":"When setting lt to 50, which stands for the less-than sign : < , only those who contributed less than 50% of lines overall are selected. Applying random will pick one from the list. automations : share_knowledge : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | rankByGitBlame ( lt = 50 ) | random }} Download and add to your repo .cm directory","title":"Share knowledge"},{"location":"examples/#mark-prs-with-deleted-files","text":"When files are removed entirely you want to be sure it is not by accident, mark these PRs. automations : deleted : if : - {{ has.deleted_files }} run : - action : add-label@v1 args : label : 'deleted-files' color : '#DF9C04' has : deleted_files : {{ source.diff.files | map ( attr = 'new_file' ) | match ( term = '/dev/null' ) | some }} Download and add to your repo .cm directory","title":"Mark PRs with deleted files"},{"location":"examples/#review-policy","text":"","title":"Review Policy"},{"location":"examples/#close-prs-when-touching-out-of-scope-files","text":"This action, once triggered, close the PR without merging. You can also replace close with requested-changes to leave the PR open but request to undo the UI changes. automations : close_ui_changes_by_non_ui : if : - {{ files | match ( regex = r / src \\ / views /) | some }} - {{ pr.author_teams | match ( term = 'ui-team' ) | nope }} run : - action : add-comment@v1 args : comment : | Please contact a member of `ui-team` team if you need to make changes to files in `src/views` - action : close@v1 Download and add to your repo .cm directory","title":"Close PRs when touching out-of-scope files"},{"location":"examples/#assign-mentors-to-new-contributors","text":"During the first 21 days, a contributor is assigned automatically to get reviews by specific people. By changing 21 you can add or reduce the amount of time. Make sure to change the reviewers according to your team members. automations : junior : if : - {{ repo.author_age < 21 and ( repo.age - repo.author_age ) >= 21 }} run : - action : add-label@v1 args : label : 'first-weeks' color : '#FBBD10' - action : add-comment@v1 args : comment : | During your first 21 days, your team lead will be assigned to review your PRs. - action : add-reviewers@v1 args : reviewers : [ popeye ] Download and add to your repo .cm directory","title":"Assign mentors to new contributors"},{"location":"examples/#validate-new-component-has-required-field","text":"You can define required fields for components, so when your team members adds new components they should also add the required field, description in the example below. automations : catch_deprecated_components : if : - {{ source.diff.files | matchDiffLines ( regex = r / LambdaFunction /) | some }} - {{ source.diff.files | matchDiffLines ( regex = r / description :/) | nope }} run : - action : add-label@v1 args : label : 'lambda-missing-field' color : '#FF0000' - action : request-changes@v1 args : comment : | New `LambdaFunction` must have `description:` field.","title":"Validate new component has required field"},{"location":"examples/#request-changes-on-deprecated-apis","text":"For example, assume we have an old API callElvis we want to switch from to a new API callGaga , gitStream can review and trigger a change request automatically when the PR includes use of the deprecated API. This pattern allows defining best practices in .cm code. automations : catch_deprecated_components : if : - {{ source.diff.files | matchDiffLines ( regex = r / callElvis /) | some }} run : - action : add-label@v1 args : label : 'deprecated-component' color : '#FF0000' - action : request-changes@v1 args : comment : | you have used deprecated API, use `callingGaga` instead gitStream supports iterators over arrays and dictionaries, so you can also make it more general: automations : {% for item in deprecated %} # Automation names should be unique, therefore the iteration number postfix catch_deprecated_components_ {{ loop .index }} : if : - {{ source.diff.files | matchDiffLines ( regex = item.regex ) | some }} run : - action : add-label@v1 args : label : 'deprecated-component' color : '#FF0000' - action : request-changes@v1 args : comment : | ` {{ item.old }} ` component is deprecated, use ` {{ item.new }} ` instead {% endfor %} # This list includes the deprecated items deprecated : - regex : r/callElvis/ old : Elvis new : Gaga - regex : r/callOldAPI/ old : callOldAPI new : callBetterAPI Download and add to your repo .cm directory","title":"Request changes on deprecated APIs"},{"location":"examples/#more-examples","text":"More examples can be found in the gitStream repository . Tip You can boost your GitHub reputation with your new automation rule - open a PR and add it to the gitStream repository","title":"More examples"},{"location":"execution-model/","text":"Execution Model gitStream is triggered on new pull requests (PRs) for repositories that have gitStream installed. Upon triggering, gitStream collects context variables and evaluates the automation rules to determine which automation rules are relevant. Organization level rules and repository rules When a central cm repository is set with the CI/CD runner, the events for PRs from all installed repositories shall be evaluated in the cm repository pipeline, taking into account the organization level rules and the PR repository rules. Triggering events By default, gitStream evaluates any new commit that is pushed to the PR, triggering automation evaluation. Additionally, if any of the automation rules reference the pr context, gitStream shall trigger and will initiate automation rules evaluation even where there are changes to the PR title, descriptions, or labels. This allows for greater flexibility in the automation process, ensuring that the relevant automation rules are evaluated and triggered when necessary. The execution model ensures that the automation process is streamlined, efficient, and effective.","title":"Execution"},{"location":"execution-model/#execution-model","text":"gitStream is triggered on new pull requests (PRs) for repositories that have gitStream installed. Upon triggering, gitStream collects context variables and evaluates the automation rules to determine which automation rules are relevant.","title":"Execution Model"},{"location":"execution-model/#organization-level-rules-and-repository-rules","text":"When a central cm repository is set with the CI/CD runner, the events for PRs from all installed repositories shall be evaluated in the cm repository pipeline, taking into account the organization level rules and the PR repository rules.","title":"Organization level rules and repository rules"},{"location":"execution-model/#triggering-events","text":"By default, gitStream evaluates any new commit that is pushed to the PR, triggering automation evaluation. Additionally, if any of the automation rules reference the pr context, gitStream shall trigger and will initiate automation rules evaluation even where there are changes to the PR title, descriptions, or labels. This allows for greater flexibility in the automation process, ensuring that the relevant automation rules are evaluated and triggered when necessary. The execution model ensures that the automation process is streamlined, efficient, and effective.","title":"Triggering events"},{"location":"faq/","text":"FAQ What permissions needed? In your repo permissions, make sure GitHub actions are permitted: Go to Repo's settings > Actions > General > Actions permissions Choose which repositories are permitted to use GitHub Actions. [x] Allow all actions and reusable workflows Does gitStream services have access to my code? Like any other CI/CD automation, the source code is being scanned in the repo and is not shared with any external services. Only metadata that relates and affects the workflow is shared to allow rule based automation on the repo. Why does gitStream require permission to write code? In order to support automations that either Approve or Merge PRs, GitHub API requires code write scope. What repos are supported? Any repo in GitHub is supported. More Git providers are planned soon. Custom filter functions Coming soon. Is there .cm syntax highlighting? The .cm file use YAML with JINJA2, in order for your favorite editor to choose automatically the right syntax, you can use modelines. Add the following line to the top of the .cm file (the default has it already): # -*- mode: yaml -*- Get a plug-in that enable modelines, popular ones are: VS Code: Modelines Sublime Text: Emacs-like Sublime Modeline Vim Modeline magic I have an issue I can seem to solve, what should I do? Go to our issues page and check if there are any similar issues already reported, if not create a new issue with all the details so we can take a look. Found a bug? Create a new item in the project's issues","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#what-permissions-needed","text":"In your repo permissions, make sure GitHub actions are permitted: Go to Repo's settings > Actions > General > Actions permissions Choose which repositories are permitted to use GitHub Actions. [x] Allow all actions and reusable workflows","title":"What permissions needed?"},{"location":"faq/#does-gitstream-services-have-access-to-my-code","text":"Like any other CI/CD automation, the source code is being scanned in the repo and is not shared with any external services. Only metadata that relates and affects the workflow is shared to allow rule based automation on the repo.","title":"Does gitStream services have access to my code?"},{"location":"faq/#why-does-gitstream-require-permission-to-write-code","text":"In order to support automations that either Approve or Merge PRs, GitHub API requires code write scope.","title":"Why does gitStream require permission to write code?"},{"location":"faq/#what-repos-are-supported","text":"Any repo in GitHub is supported. More Git providers are planned soon.","title":"What repos are supported?"},{"location":"faq/#custom-filter-functions","text":"Coming soon.","title":"Custom filter functions"},{"location":"faq/#is-there-cm-syntax-highlighting","text":"The .cm file use YAML with JINJA2, in order for your favorite editor to choose automatically the right syntax, you can use modelines. Add the following line to the top of the .cm file (the default has it already): # -*- mode: yaml -*- Get a plug-in that enable modelines, popular ones are: VS Code: Modelines Sublime Text: Emacs-like Sublime Modeline Vim Modeline magic","title":"Is there .cm syntax highlighting?"},{"location":"faq/#i-have-an-issue-i-can-seem-to-solve-what-should-i-do","text":"Go to our issues page and check if there are any similar issues already reported, if not create a new issue with all the details so we can take a look. Found a bug? Create a new item in the project's issues","title":"I have an issue I can seem to solve, what should I do?"},{"location":"filter-functions/","text":"Filter functions Filters can change the look and format of the source data, or even generate new data derived from the input values. What's important is that the original data is replaced by the result of transformations, and that's what ends up in rendered templates. Note Items marked with are under development and are not available yet. Overview The following functions are supported in addition to the built-in functions provided by Nunjucks . Low level functions Function Input Args Output every Checks whether all element in the list are true [Bool] - Bool filter Reduce list of items into a list of same items that match the specified term [String] [Object] regex , term , list , attr [String] [Object] includes Check if substring match String regex , term , list Bool map Maps each object in a list into their specified attribute value [Object] attr [Object] match Maps list of items into a list of booleans that match the specified term [String] [Object] regex , term , list attr [Bool] nope Checks whether all element in the list are false [Bool] - Bool reject Inverse of filter , the result list contains non-matching items [String] [Object] regex , term , list , attr [String] [Object] some Checks whether at least one element in the list is true [Bool] - Bool High level functions Function Input Args Output allDocs Checks the list includes only documents files - Bool allImages Checks the list includes only images files - Bool allTests Checks the list includes only tests files - Bool codeExperts Get list of contributors based on expert reviewer model results repo gt , lt [String] estimatedReviewTime Estimated review time in minutes branch - Integer extensions Lists all the unique file extensions [String] - [String] explainCodeExperts Short markdown text explaining codeExperts results repo gt , lt [String] explainRankByGitBlame Short markdown text explaining rankByGitBlame results repo gt , lt [String] isFirstCommit Checks if its the author first commit in the repo repo.contributors String Bool isFormattingChange Checks that only formatting changed [ FileDiff ] - Bool matchDiffLines Match every line in diff [ FileDiff ] regex , ignoreWhiteSpaces [Bool] rankByGitActivity Get list of contributors based on git-commit activity repo gt , lt [String] rankByGitBlame Get list of contributors based on git-blame results repo gt , lt [String] Named arguments Some functions supports named arguments, many of these repeat in different functions. term - a single string, used as substring to match with the matched item. list - a list of strings, trying to match any of the listed substrings with the matched item. regex - a single string, used as regular expression to with the matched item. A regular expression can be created just like JavaScript, but needs to be prefixed with r, for example r/^foo.*/g , for more info see Nunjucks . globs - a key to an element in the .cm that holds a list of strings, used as glob pattern test on the matched item. For more info, see Wikipedia . attr - a key in the element to use when doing the requested operation. For example, the following expressions provide an identical result: - {{ 'something' | includes ( regex = r / ^ some . */) }} - {{ 'something' | includes ( term = 'some' ) }} - {{ 'something' | includes ( list =[ 'some' ]) }} Reference every Checks whether all element in the list are true . In case the list of elements is empty, it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when all list items are true For example, check that all changes are in either 'src' or 'dest' directories: {{ files | match ( list =[ 'src' , 'dest' ]) | every }} filter Creates a shallow copy of a portion of a given list, filtered down to just the elements that match the given term. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input [String] [Object] The list of strings to match, or list of objects if attr is used term regex list Input (either) String String [String] Search term to match with the input items attr Input (optional) String match a named attribute in the input object - Output [String] [Object] The list with only the matching items For example, check if all changes to JavaScript files are in tests directory: {{ files | filter ( regex = r / \\ .js $ /) | match ( regex = r / tests \\ //) | every }} For example, check if all changes to JavaScript files are formatting: {{ source.diff.files | filter ( attr = 'new_file' , regex = r / \\ .js $ /) | isFormattingChange }} includes Determines whether a string includes a certain substring. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input String The list of strings to match term regex list Input (either) String String [String] Substring term to match - Output Bool true if search terms matches Check string matches either of the terms: {{ 'something' | includes ( list =[ 'any' , 'thing' ]) }} map Creates a new list populated with the values of the selected attribute of every element in the input list. Argument Usage Type Description - Input [Object] The list of objects to map, see context for valid inputs attr Input String Object attribute to select - Output [Object] List of the selected object attributes For example, the source.diff.files context holds a list of FileDiff , each has new_file attribute. You can create a list of all the new file names by mapping to the new_file attribute and then check if there are changes to any handler.js file: {{ source.diff.files | map ( attr = 'new_file' ) | match ( term = 'handler.js' ) | some }} match Return true for each element in the list that match the search term. Argument Usage Type Description - Input [String] [Object] The list of strings or if attr used the list of objects term regex list Input (either) String String [String] Search term to match attr Input String match a named attribute in the input object - Output [Bool] true for every matching item For example, to check if all code changes are in the tests directory: {{ files | match ( regex = r / tests \\ //) | every }} For example, to check if there are code changes with specific function call: {{ source.diff.files | match ( attr = 'diff' , term = 'myFunction' ) | some }} nope The inverse of every , checks whether all element in the list are false . In case the list of elements is empty, it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when all list items are false For example, check that no changes in either 'src' or 'dest' directories: {{ files | match ( list =[ 'src' , 'dest' ]) | nope }} reject Creates a shallow copy of a portion of a given list, filtered down to just the elements that does not match the given term. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input [String] [Object] The list of strings to match, or list of objects if attr is used term regex list Input (either) String String [String] Search term to match with the input items attr Input (optional) String match a named attribute in the input object - Output [String] [Object] The list with only the non-matching items For example, check if all changes, but JavaScript files are in tests directory: {{ files | reject ( regex = r / \\ .js $ /) | match ( regex = r / tests \\ // ' ) | every }} For example, check if all changes except for config.json files are formatting: {{ source.diff.files | reject ( attr = 'new_file' , regex = r / config \\ .json $ /) | isFormattingChange }} some Checks whether any element in the list is true . In case the list of elements is empty it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when any of the items is true {{ files | match ( list =[ 'src' , 'dest' ]) | some }} allDocs Return true if the input list includes only documents based on file extensions. Doc files extensions are: md , mkdown , txt , rst , except for requirements.txt . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file extensions are of docs {{ files | allDocs }} In case you want to exclude more files, like all txt under requirements directory, add another check: {{ ( files | allDocs ) and ( files | match ( regex = r / requirements \\ / . * \\ .txt $ /) | nope ) }} allImages Return true if the input list includes only images based on file extensions. Image file extensions are: svg , png , gif . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file extensions are of images {{ files | allImages }} allTests Return true if the input list includes only tests based on file's path and name. To identify as test the file must include the word test or spec in its name or path, it is checked using this regex: [^a-zA-Z0-9](spec|test|tests)[^a-zA-Z0-9] . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file tests based on name and path {{ files | allTests }} codeExperts When requesting a review for a pull request, it's important to select a reviewer who has a deep understanding of the relevant code area, the domain problem, and the framework being used. This ensures that the reviewer can provide specific and informed feedback, rather than general comments that may not take into account the context in which the issue was solved. The filter provides the list of most qualified contributors based on git-blame and git-commit results to determine who has been most active in the relevant code area, and then combines this information into a score between 0 and 100. The commit activity is scored higher for recent commits, which ensures that those who are actively contributing to the codebase are given higher priority as potential reviewers. The result will be limited to 2 users and shall not include the PR author. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines. Note The codeExperts filter function calls gitStream app API with the repo context to calculate the estimated review time value. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] Up to 2 users, sorted by best match first (it won't include the PR author) For example: automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} estimatedReviewTime Returns the estimated review time in minutes based on statistical model. The model uses the amount of additions and deletions statistics for each file type with additional information about the commits and base branch. Note The estimatedReviewTime filter function calls gitStream app API with the branch context to calculate the estimated review time value. The following files are excluded when calculating this value: Argument Usage Type Description - Input branch Branch meta data - Output Integer the estimated time for review in minutes {{ branch | estimatedReviewTime }} The following files are automatically excluded from the estimated review time calculation. File type Filter type Values Data Extension ini csv xls xlsx xlr doc docx txt pps ppt pptx dot dotx log tar rtf dat ipynb po profile object obj dxf twb bcsymbolmap tfstate pdf rbi pem crt svg png jpeg jpg ttf Data Regex .*dist/.*\\.js$ .*public/assets/.*\\.js$ Lock Regex .*package-lock|packages\\.lock|package)\\.json$ Lock File yarn.lock gemfile.lock podfile.lock cargo.lock composer.lock pipfile.lock gopkg.lock Lock Regex .*gradle\\.lockfile$ .*lock\\.sbt$ Pipeline Regex .*ci\\.yml$ Tip You can also filter more files, using config.ignore_files . extensions Expects files and provide a list of all unique file extensions. Argument Usage Type Description - Input files The list of changed files with their path - Output [String] List of all unique file extensions For example, check that only one file type was changed: {{ files | extensions | length == 1 }} explainCodeExperts This filter helps to explain the results of codeExperts , the output is in Markdown format that can be used in a PR comment. Note The explainCodeExperts filter function calls gitStream app API with the repo context to calculate the estimated review time value. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining codeExperts results in markdown format For example: automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Note the comment starts with | and a new-line as explainCodeExperts generates a multiline comment. explainRankByGitBlame This filter helps to explain the results of rankByGitBlame , the output is in Markdown format that can be used in a PR comment. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. Git users that could not be automatically mapped are marked with * . To map these users, you can add user_mapping see instructions here . Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining rankByGitBlame results in markdown format Note Each contributor's result is rounded down to the nearest integer, so the total may add up to less than 100%. For example: automations : the_right_reviewer : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | rankByGitBlame ( gt = 50 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainRankByGitBlame ( gt = 50 ) }} Note the comment starts with | and a new-line as explainRankByGitBlame generates a multiline comment. isFirstCommit Return true if it's the author first commit in the repo. Argument Usage Type Description - Input repo.contributors List of contributors in the repo - Input String The contributor name - Output Bool true if its the first commit of the selected contributor if : - {{ repo.contributors | isFirstCommit ( branch.author ) }} run : - action : add-comment@v1 args : comment : Welcome {{ branch.author }} ! isFormattingChange Return true if all file diffs are validated as formatting changes. Support source code languages: JavaScript, TypeScript, JSON, YAML and HTML. If changes in other formats detected, the filter will return false . Argument Usage Type Description - Input source.diff.files List of file diffs - Output Bool true if the all code changes are non functional {{ source.diff.files | isFormattingChange }} matchDiffLines Checks diff for matching lines. Argument Usage Type Description - Input [Object] The list of objects regex Input String Regex term to match with the input items, use \\\\ for \\ ignoreWhiteSpaces Input Bool false by default, match a named attribute in the input object caseSensitive Input Bool true by default, ignore case when matching terms - Output [Bool] true for every matching object For example, to check if all the changes are of adding prints and ignore white spaces: {{ source.diff.files | matchDiffLines ( regex = r / ^\\ + . * console \\ .log /, ignoreWhiteSpaces = true ) | every }} rankByGitActivity Get list of contributors based on git-commit activity. The repo context includes all the changed files, for each file it includes each contributor number of lines changed every week over the last 52 weeks, based on git-commit . These functions compare each contributor changes per week and yield an average percentage of contribution for any given file. For example, in a certain week a file had 500 line changed, 200 by a first user, while 3 other users changed 100 lines each. So the score for the first user in that week will be 40 (200/500 in %). The function then average the score for each user for the selected time period. Then you can use the thresholds to get the right reviewer. Argument Usage Type Description - Input repo The repo context variable weeks Input Integer The number of last weeks to include lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison Check if the branch author is a rookie active_coders : {{ repo | rankByGitActivity ( gt = 50 , weeks = 12 ) }} rankByGitBlame Get list of contributors based on git-blame results The repo context includes all the changed files, for each file it includes the contributors' percentage of lines in the file, based on git-blame . This function sums all these percentages per user and yield an average percentage of contribution. Then you can use the thresholds to get the right reviewer. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison, sorted by rank - first has highest score Example of the filter output, note the output are GitHub users in the example: [ \"PopeyeUser\" , \"olive_user\" , \"BRUTUS_USER\" ] Get the most significant contributors for the PR files: contributors : {{ repo | rankByGitBlame ( gt = 30 ) }} Check if the branch author is a rookie is_rookie : {{ repo | rankByGitBlame ( lt = 15 ) | match ( term = branch.author ) | some }}","title":"Filter functions"},{"location":"filter-functions/#filter-functions","text":"Filters can change the look and format of the source data, or even generate new data derived from the input values. What's important is that the original data is replaced by the result of transformations, and that's what ends up in rendered templates. Note Items marked with are under development and are not available yet.","title":"Filter functions"},{"location":"filter-functions/#overview","text":"The following functions are supported in addition to the built-in functions provided by Nunjucks .","title":"Overview"},{"location":"filter-functions/#low-level-functions","text":"Function Input Args Output every Checks whether all element in the list are true [Bool] - Bool filter Reduce list of items into a list of same items that match the specified term [String] [Object] regex , term , list , attr [String] [Object] includes Check if substring match String regex , term , list Bool map Maps each object in a list into their specified attribute value [Object] attr [Object] match Maps list of items into a list of booleans that match the specified term [String] [Object] regex , term , list attr [Bool] nope Checks whether all element in the list are false [Bool] - Bool reject Inverse of filter , the result list contains non-matching items [String] [Object] regex , term , list , attr [String] [Object] some Checks whether at least one element in the list is true [Bool] - Bool","title":"Low level functions"},{"location":"filter-functions/#high-level-functions","text":"Function Input Args Output allDocs Checks the list includes only documents files - Bool allImages Checks the list includes only images files - Bool allTests Checks the list includes only tests files - Bool codeExperts Get list of contributors based on expert reviewer model results repo gt , lt [String] estimatedReviewTime Estimated review time in minutes branch - Integer extensions Lists all the unique file extensions [String] - [String] explainCodeExperts Short markdown text explaining codeExperts results repo gt , lt [String] explainRankByGitBlame Short markdown text explaining rankByGitBlame results repo gt , lt [String] isFirstCommit Checks if its the author first commit in the repo repo.contributors String Bool isFormattingChange Checks that only formatting changed [ FileDiff ] - Bool matchDiffLines Match every line in diff [ FileDiff ] regex , ignoreWhiteSpaces [Bool] rankByGitActivity Get list of contributors based on git-commit activity repo gt , lt [String] rankByGitBlame Get list of contributors based on git-blame results repo gt , lt [String]","title":"High level functions"},{"location":"filter-functions/#named-arguments","text":"Some functions supports named arguments, many of these repeat in different functions. term - a single string, used as substring to match with the matched item. list - a list of strings, trying to match any of the listed substrings with the matched item. regex - a single string, used as regular expression to with the matched item. A regular expression can be created just like JavaScript, but needs to be prefixed with r, for example r/^foo.*/g , for more info see Nunjucks . globs - a key to an element in the .cm that holds a list of strings, used as glob pattern test on the matched item. For more info, see Wikipedia . attr - a key in the element to use when doing the requested operation. For example, the following expressions provide an identical result: - {{ 'something' | includes ( regex = r / ^ some . */) }} - {{ 'something' | includes ( term = 'some' ) }} - {{ 'something' | includes ( list =[ 'some' ]) }}","title":"Named arguments"},{"location":"filter-functions/#reference","text":"","title":"Reference"},{"location":"filter-functions/#every","text":"Checks whether all element in the list are true . In case the list of elements is empty, it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when all list items are true For example, check that all changes are in either 'src' or 'dest' directories: {{ files | match ( list =[ 'src' , 'dest' ]) | every }}","title":"every"},{"location":"filter-functions/#filter","text":"Creates a shallow copy of a portion of a given list, filtered down to just the elements that match the given term. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input [String] [Object] The list of strings to match, or list of objects if attr is used term regex list Input (either) String String [String] Search term to match with the input items attr Input (optional) String match a named attribute in the input object - Output [String] [Object] The list with only the matching items For example, check if all changes to JavaScript files are in tests directory: {{ files | filter ( regex = r / \\ .js $ /) | match ( regex = r / tests \\ //) | every }} For example, check if all changes to JavaScript files are formatting: {{ source.diff.files | filter ( attr = 'new_file' , regex = r / \\ .js $ /) | isFormattingChange }}","title":"filter"},{"location":"filter-functions/#includes","text":"Determines whether a string includes a certain substring. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input String The list of strings to match term regex list Input (either) String String [String] Substring term to match - Output Bool true if search terms matches Check string matches either of the terms: {{ 'something' | includes ( list =[ 'any' , 'thing' ]) }}","title":"includes"},{"location":"filter-functions/#map","text":"Creates a new list populated with the values of the selected attribute of every element in the input list. Argument Usage Type Description - Input [Object] The list of objects to map, see context for valid inputs attr Input String Object attribute to select - Output [Object] List of the selected object attributes For example, the source.diff.files context holds a list of FileDiff , each has new_file attribute. You can create a list of all the new file names by mapping to the new_file attribute and then check if there are changes to any handler.js file: {{ source.diff.files | map ( attr = 'new_file' ) | match ( term = 'handler.js' ) | some }}","title":"map"},{"location":"filter-functions/#match","text":"Return true for each element in the list that match the search term. Argument Usage Type Description - Input [String] [Object] The list of strings or if attr used the list of objects term regex list Input (either) String String [String] Search term to match attr Input String match a named attribute in the input object - Output [Bool] true for every matching item For example, to check if all code changes are in the tests directory: {{ files | match ( regex = r / tests \\ //) | every }} For example, to check if there are code changes with specific function call: {{ source.diff.files | match ( attr = 'diff' , term = 'myFunction' ) | some }}","title":"match"},{"location":"filter-functions/#nope","text":"The inverse of every , checks whether all element in the list are false . In case the list of elements is empty, it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when all list items are false For example, check that no changes in either 'src' or 'dest' directories: {{ files | match ( list =[ 'src' , 'dest' ]) | nope }}","title":"nope"},{"location":"filter-functions/#reject","text":"Creates a shallow copy of a portion of a given list, filtered down to just the elements that does not match the given term. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input [String] [Object] The list of strings to match, or list of objects if attr is used term regex list Input (either) String String [String] Search term to match with the input items attr Input (optional) String match a named attribute in the input object - Output [String] [Object] The list with only the non-matching items For example, check if all changes, but JavaScript files are in tests directory: {{ files | reject ( regex = r / \\ .js $ /) | match ( regex = r / tests \\ // ' ) | every }} For example, check if all changes except for config.json files are formatting: {{ source.diff.files | reject ( attr = 'new_file' , regex = r / config \\ .json $ /) | isFormattingChange }}","title":"reject"},{"location":"filter-functions/#some","text":"Checks whether any element in the list is true . In case the list of elements is empty it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when any of the items is true {{ files | match ( list =[ 'src' , 'dest' ]) | some }}","title":"some"},{"location":"filter-functions/#alldocs","text":"Return true if the input list includes only documents based on file extensions. Doc files extensions are: md , mkdown , txt , rst , except for requirements.txt . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file extensions are of docs {{ files | allDocs }} In case you want to exclude more files, like all txt under requirements directory, add another check: {{ ( files | allDocs ) and ( files | match ( regex = r / requirements \\ / . * \\ .txt $ /) | nope ) }}","title":"allDocs"},{"location":"filter-functions/#allimages","text":"Return true if the input list includes only images based on file extensions. Image file extensions are: svg , png , gif . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file extensions are of images {{ files | allImages }}","title":"allImages"},{"location":"filter-functions/#alltests","text":"Return true if the input list includes only tests based on file's path and name. To identify as test the file must include the word test or spec in its name or path, it is checked using this regex: [^a-zA-Z0-9](spec|test|tests)[^a-zA-Z0-9] . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file tests based on name and path {{ files | allTests }}","title":"allTests"},{"location":"filter-functions/#codeexperts","text":"When requesting a review for a pull request, it's important to select a reviewer who has a deep understanding of the relevant code area, the domain problem, and the framework being used. This ensures that the reviewer can provide specific and informed feedback, rather than general comments that may not take into account the context in which the issue was solved. The filter provides the list of most qualified contributors based on git-blame and git-commit results to determine who has been most active in the relevant code area, and then combines this information into a score between 0 and 100. The commit activity is scored higher for recent commits, which ensures that those who are actively contributing to the codebase are given higher priority as potential reviewers. The result will be limited to 2 users and shall not include the PR author. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines. Note The codeExperts filter function calls gitStream app API with the repo context to calculate the estimated review time value. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] Up to 2 users, sorted by best match first (it won't include the PR author) For example: automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }}","title":"codeExperts"},{"location":"filter-functions/#estimatedreviewtime","text":"Returns the estimated review time in minutes based on statistical model. The model uses the amount of additions and deletions statistics for each file type with additional information about the commits and base branch. Note The estimatedReviewTime filter function calls gitStream app API with the branch context to calculate the estimated review time value. The following files are excluded when calculating this value: Argument Usage Type Description - Input branch Branch meta data - Output Integer the estimated time for review in minutes {{ branch | estimatedReviewTime }} The following files are automatically excluded from the estimated review time calculation. File type Filter type Values Data Extension ini csv xls xlsx xlr doc docx txt pps ppt pptx dot dotx log tar rtf dat ipynb po profile object obj dxf twb bcsymbolmap tfstate pdf rbi pem crt svg png jpeg jpg ttf Data Regex .*dist/.*\\.js$ .*public/assets/.*\\.js$ Lock Regex .*package-lock|packages\\.lock|package)\\.json$ Lock File yarn.lock gemfile.lock podfile.lock cargo.lock composer.lock pipfile.lock gopkg.lock Lock Regex .*gradle\\.lockfile$ .*lock\\.sbt$ Pipeline Regex .*ci\\.yml$ Tip You can also filter more files, using config.ignore_files .","title":"estimatedReviewTime"},{"location":"filter-functions/#extensions","text":"Expects files and provide a list of all unique file extensions. Argument Usage Type Description - Input files The list of changed files with their path - Output [String] List of all unique file extensions For example, check that only one file type was changed: {{ files | extensions | length == 1 }}","title":"extensions"},{"location":"filter-functions/#explaincodeexperts","text":"This filter helps to explain the results of codeExperts , the output is in Markdown format that can be used in a PR comment. Note The explainCodeExperts filter function calls gitStream app API with the repo context to calculate the estimated review time value. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining codeExperts results in markdown format For example: automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Note the comment starts with | and a new-line as explainCodeExperts generates a multiline comment.","title":"explainCodeExperts"},{"location":"filter-functions/#explainrankbygitblame","text":"This filter helps to explain the results of rankByGitBlame , the output is in Markdown format that can be used in a PR comment. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. Git users that could not be automatically mapped are marked with * . To map these users, you can add user_mapping see instructions here . Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining rankByGitBlame results in markdown format Note Each contributor's result is rounded down to the nearest integer, so the total may add up to less than 100%. For example: automations : the_right_reviewer : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | rankByGitBlame ( gt = 50 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainRankByGitBlame ( gt = 50 ) }} Note the comment starts with | and a new-line as explainRankByGitBlame generates a multiline comment.","title":"explainRankByGitBlame"},{"location":"filter-functions/#isfirstcommit","text":"Return true if it's the author first commit in the repo. Argument Usage Type Description - Input repo.contributors List of contributors in the repo - Input String The contributor name - Output Bool true if its the first commit of the selected contributor if : - {{ repo.contributors | isFirstCommit ( branch.author ) }} run : - action : add-comment@v1 args : comment : Welcome {{ branch.author }} !","title":"isFirstCommit"},{"location":"filter-functions/#isformattingchange","text":"Return true if all file diffs are validated as formatting changes. Support source code languages: JavaScript, TypeScript, JSON, YAML and HTML. If changes in other formats detected, the filter will return false . Argument Usage Type Description - Input source.diff.files List of file diffs - Output Bool true if the all code changes are non functional {{ source.diff.files | isFormattingChange }}","title":"isFormattingChange"},{"location":"filter-functions/#matchdifflines","text":"Checks diff for matching lines. Argument Usage Type Description - Input [Object] The list of objects regex Input String Regex term to match with the input items, use \\\\ for \\ ignoreWhiteSpaces Input Bool false by default, match a named attribute in the input object caseSensitive Input Bool true by default, ignore case when matching terms - Output [Bool] true for every matching object For example, to check if all the changes are of adding prints and ignore white spaces: {{ source.diff.files | matchDiffLines ( regex = r / ^\\ + . * console \\ .log /, ignoreWhiteSpaces = true ) | every }}","title":"matchDiffLines"},{"location":"filter-functions/#rankbygitactivity","text":"Get list of contributors based on git-commit activity. The repo context includes all the changed files, for each file it includes each contributor number of lines changed every week over the last 52 weeks, based on git-commit . These functions compare each contributor changes per week and yield an average percentage of contribution for any given file. For example, in a certain week a file had 500 line changed, 200 by a first user, while 3 other users changed 100 lines each. So the score for the first user in that week will be 40 (200/500 in %). The function then average the score for each user for the selected time period. Then you can use the thresholds to get the right reviewer. Argument Usage Type Description - Input repo The repo context variable weeks Input Integer The number of last weeks to include lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison Check if the branch author is a rookie active_coders : {{ repo | rankByGitActivity ( gt = 50 , weeks = 12 ) }}","title":"rankByGitActivity"},{"location":"filter-functions/#rankbygitblame","text":"Get list of contributors based on git-blame results The repo context includes all the changed files, for each file it includes the contributors' percentage of lines in the file, based on git-blame . This function sums all these percentages per user and yield an average percentage of contribution. Then you can use the thresholds to get the right reviewer. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison, sorted by rank - first has highest score Example of the filter output, note the output are GitHub users in the example: [ \"PopeyeUser\" , \"olive_user\" , \"BRUTUS_USER\" ] Get the most significant contributors for the PR files: contributors : {{ repo | rankByGitBlame ( gt = 30 ) }} Check if the branch author is a rookie is_rookie : {{ repo | rankByGitBlame ( lt = 15 ) | match ( term = branch.author ) | some }}","title":"rankByGitBlame"},{"location":"github-installation/","text":"How to Setup gitStream with GitHub Install gitStream Before you can complete the gitStream setup process, you need to install the gitStream app to your GitHub organization . Setup You can set up gitStream for a single repo or your entire GitHub organization. Select the tab below for the instructions you want. Single Repo GitHub Organization Single Repo Setup You must implement two main components for gitStream to function for a single GitHub repo. The first is a configuration file that defines the workflow automations to execute for the repo. The second is a GitHub actions configuration file that triggers gitStream when PRs are created or updated. Required Configurations gitStream Create a .cm/gitstream.cm rules file in your repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on the repo, and you can name it anything you want as long as it ends in .cm Here is an example of a gitStream configuration file you can use to setup some basic workflow automations. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. code_experts : if : - true run : - action : add-comment@v1 # More info about explainCodeExperts: https://docs.gitstream.cm/filter-functions/#explaincodeexperts args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} Github Actions Once your gitStream configuration file is setup, you need a Github Actions configuration file to trigger gitStream automations. Create a .github/workflows/gitstream.yml file in your repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream GitHub app - DO NOT EDIT name : gitStream workflow automation run-name : | /:\\ gitStream: PR #$ {{ fromJSON ( fromJSON ( github.event.inputs.client_payload )) .pullRequestNumber }} from $ {{ github.event.inputs.full_repository }} on : workflow_dispatch : inputs : client_payload : description : The Client payload required : true full_repository : description : the repository name include the owner in `owner/repo_name` format required : true head_ref : description : the head sha required : true base_ref : description : the base ref required : true installation_id : description : the installation id required : false resolver_url : description : the resolver url to pass results to required : true resolver_token : description : Optional resolver token for resolver service required : false default : '' jobs : gitStream : timeout-minutes : 5 runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 id : rules-engine with : full_repository : $ {{ github.event.inputs.full_repository }} head_ref : $ {{ github.event.inputs.head_ref }} base_ref : $ {{ github.event.inputs.base_ref }} client_payload : $ {{ github.event.inputs.client_payload }} installation_id : $ {{ github.event.inputs.installation_id }} resolver_url : $ {{ github.event.inputs.resolver_url }} resolver_token : $ {{ github.event.inputs.resolver_token }} Success When finished, you should have the following file structure in your repo. . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml GitHub Organization Setup Organization rules are ideal when you want to enforce consistent rules across every repo in your organization. You can define them by creating a special repository named cm in your GitHub organization where you can add automation files that will apply to all repositories within that organization. Required Configurations Create a Continuous Merge Repo To begin, create a repository named cm in your GitHub organization. The repo can be either public or private; no other repo configurations are required at this time. gitStream Create a gitstream.cm rules file in the root directory of your repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on your organization's repos. You can name it anything you want as long as it ends in .cm Configuration files go in the repo's root directory. Unlike the set up instructions for a single repo, your .cm files should be placed in the repository's root directory. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. code_experts : if : - true run : - action : add-comment@v1 # More info about explainCodeExperts: https://docs.gitstream.cm/filter-functions/#explaincodeexperts args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} GitHub Actions Once your gitStream configuration file is set up, you will need to create a Github Actions configuration file to trigger gitStream automations. Create a .github/workflows/gitstream.yml file in your cm repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream GitHub app - DO NOT EDIT name : gitStream workflow automation run-name : | /:\\ gitStream: PR #$ {{ fromJSON ( fromJSON ( github.event.inputs.client_payload )) .pullRequestNumber }} from $ {{ github.event.inputs.full_repository }} on : workflow_dispatch : inputs : client_payload : description : The Client payload required : true full_repository : description : the repository name include the owner in `owner/repo_name` format required : true head_ref : description : the head sha required : true base_ref : description : the base ref required : true installation_id : description : the installation id required : false resolver_url : description : the resolver url to pass results to required : true resolver_token : description : Optional resolver token for resolver service required : false default : '' jobs : gitStream : timeout-minutes : 5 runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 id : rules-engine with : full_repository : $ {{ github.event.inputs.full_repository }} head_ref : $ {{ github.event.inputs.head_ref }} base_ref : $ {{ github.event.inputs.base_ref }} client_payload : $ {{ github.event.inputs.client_payload }} installation_id : $ {{ github.event.inputs.installation_id }} resolver_url : $ {{ github.event.inputs.resolver_url }} resolver_token : $ {{ github.event.inputs.resolver_token }} Success Once finished, all PRs to your organization's repositories will be processed by the GitHub Action in this repo, and your cm repo should have a file directory that looks like this. . \u251c\u2500 gitstream.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml Next steps Here are some additional resources to help you get the most out of gitStream Quick Start Guide - Short configuration examples you can implement in a couple of minutes Configuration overview - Learn how to get the most out of .cm configurations. How gitStream works - An overview of the gitStream lifecycle. Merge Blocking If you want to allow gitStream to block merges, you need to make gitStream a required check for each individual repository. FAQ What permissions does gitStream require to function? Permissions Reason Write access to dedicated gitStream app files Used to set up the gitStream workflow files Write access to code To allow gitStream to approve PRs once all conditions are met Read access to administration, issues, and metadata To get the user team membership, and branch protection settings Read and write access to actions, checks, pull requests, and workflows Trigger workflows, create and update pull requests and their checks, and modify workflow files User email Used to identify users How do I configure gitStream to block merges? You can configure Github to require gitStream checks to pass before PRs can be merged using branch protection rules . Run a gitStream check before continuing You need to run a check using your gitStream configuration at least once before it can be set as a required check. Make sure to open at least 1 PR before doing this setting. Here are the steps to configure gitStream in your repo's branch protection rules. Go to repo settings On the left panel select Code and automation > Branches Set Branch protection rules for your desired branch Enable Require status checks to pass before merging Search for status checks in the last week for this repository Select gitStream.cm as required check","title":"GitHub Setup"},{"location":"github-installation/#how-to-setup-gitstream-with-github","text":"Install gitStream Before you can complete the gitStream setup process, you need to install the gitStream app to your GitHub organization .","title":"How to Setup gitStream with GitHub"},{"location":"github-installation/#setup","text":"You can set up gitStream for a single repo or your entire GitHub organization. Select the tab below for the instructions you want. Single Repo GitHub Organization Single Repo Setup You must implement two main components for gitStream to function for a single GitHub repo. The first is a configuration file that defines the workflow automations to execute for the repo. The second is a GitHub actions configuration file that triggers gitStream when PRs are created or updated. Required Configurations gitStream Create a .cm/gitstream.cm rules file in your repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on the repo, and you can name it anything you want as long as it ends in .cm Here is an example of a gitStream configuration file you can use to setup some basic workflow automations. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. code_experts : if : - true run : - action : add-comment@v1 # More info about explainCodeExperts: https://docs.gitstream.cm/filter-functions/#explaincodeexperts args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} Github Actions Once your gitStream configuration file is setup, you need a Github Actions configuration file to trigger gitStream automations. Create a .github/workflows/gitstream.yml file in your repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream GitHub app - DO NOT EDIT name : gitStream workflow automation run-name : | /:\\ gitStream: PR #$ {{ fromJSON ( fromJSON ( github.event.inputs.client_payload )) .pullRequestNumber }} from $ {{ github.event.inputs.full_repository }} on : workflow_dispatch : inputs : client_payload : description : The Client payload required : true full_repository : description : the repository name include the owner in `owner/repo_name` format required : true head_ref : description : the head sha required : true base_ref : description : the base ref required : true installation_id : description : the installation id required : false resolver_url : description : the resolver url to pass results to required : true resolver_token : description : Optional resolver token for resolver service required : false default : '' jobs : gitStream : timeout-minutes : 5 runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 id : rules-engine with : full_repository : $ {{ github.event.inputs.full_repository }} head_ref : $ {{ github.event.inputs.head_ref }} base_ref : $ {{ github.event.inputs.base_ref }} client_payload : $ {{ github.event.inputs.client_payload }} installation_id : $ {{ github.event.inputs.installation_id }} resolver_url : $ {{ github.event.inputs.resolver_url }} resolver_token : $ {{ github.event.inputs.resolver_token }} Success When finished, you should have the following file structure in your repo. . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml GitHub Organization Setup Organization rules are ideal when you want to enforce consistent rules across every repo in your organization. You can define them by creating a special repository named cm in your GitHub organization where you can add automation files that will apply to all repositories within that organization. Required Configurations Create a Continuous Merge Repo To begin, create a repository named cm in your GitHub organization. The repo can be either public or private; no other repo configurations are required at this time. gitStream Create a gitstream.cm rules file in the root directory of your repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on your organization's repos. You can name it anything you want as long as it ends in .cm Configuration files go in the repo's root directory. Unlike the set up instructions for a single repo, your .cm files should be placed in the repository's root directory. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. code_experts : if : - true run : - action : add-comment@v1 # More info about explainCodeExperts: https://docs.gitstream.cm/filter-functions/#explaincodeexperts args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} GitHub Actions Once your gitStream configuration file is set up, you will need to create a Github Actions configuration file to trigger gitStream automations. Create a .github/workflows/gitstream.yml file in your cm repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream GitHub app - DO NOT EDIT name : gitStream workflow automation run-name : | /:\\ gitStream: PR #$ {{ fromJSON ( fromJSON ( github.event.inputs.client_payload )) .pullRequestNumber }} from $ {{ github.event.inputs.full_repository }} on : workflow_dispatch : inputs : client_payload : description : The Client payload required : true full_repository : description : the repository name include the owner in `owner/repo_name` format required : true head_ref : description : the head sha required : true base_ref : description : the base ref required : true installation_id : description : the installation id required : false resolver_url : description : the resolver url to pass results to required : true resolver_token : description : Optional resolver token for resolver service required : false default : '' jobs : gitStream : timeout-minutes : 5 runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 id : rules-engine with : full_repository : $ {{ github.event.inputs.full_repository }} head_ref : $ {{ github.event.inputs.head_ref }} base_ref : $ {{ github.event.inputs.base_ref }} client_payload : $ {{ github.event.inputs.client_payload }} installation_id : $ {{ github.event.inputs.installation_id }} resolver_url : $ {{ github.event.inputs.resolver_url }} resolver_token : $ {{ github.event.inputs.resolver_token }} Success Once finished, all PRs to your organization's repositories will be processed by the GitHub Action in this repo, and your cm repo should have a file directory that looks like this. . \u251c\u2500 gitstream.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml","title":"Setup"},{"location":"github-installation/#next-steps","text":"Here are some additional resources to help you get the most out of gitStream Quick Start Guide - Short configuration examples you can implement in a couple of minutes Configuration overview - Learn how to get the most out of .cm configurations. How gitStream works - An overview of the gitStream lifecycle. Merge Blocking If you want to allow gitStream to block merges, you need to make gitStream a required check for each individual repository.","title":"Next steps"},{"location":"github-installation/#faq","text":"","title":"FAQ"},{"location":"github-installation/#what-permissions-does-gitstream-require-to-function","text":"Permissions Reason Write access to dedicated gitStream app files Used to set up the gitStream workflow files Write access to code To allow gitStream to approve PRs once all conditions are met Read access to administration, issues, and metadata To get the user team membership, and branch protection settings Read and write access to actions, checks, pull requests, and workflows Trigger workflows, create and update pull requests and their checks, and modify workflow files User email Used to identify users","title":"What permissions does gitStream require to function?"},{"location":"github-installation/#how-do-i-configure-gitstream-to-block-merges","text":"You can configure Github to require gitStream checks to pass before PRs can be merged using branch protection rules . Run a gitStream check before continuing You need to run a check using your gitStream configuration at least once before it can be set as a required check. Make sure to open at least 1 PR before doing this setting. Here are the steps to configure gitStream in your repo's branch protection rules. Go to repo settings On the left panel select Code and automation > Branches Set Branch protection rules for your desired branch Enable Require status checks to pass before merging Search for status checks in the last week for this repository Select gitStream.cm as required check","title":"How do I configure gitStream to block merges? "},{"location":"github-org-level/","text":"Deprecated","title":"Github org level"},{"location":"github-required-check/","text":"Deprecated","title":"Github required check"},{"location":"gitlab-installation/","text":"GitLab installation Prerequisites: GitLab cloud GitLab runner v15 or higher Tip Automation rules by gitStream are executed on behalf of the user account used to install it. We recommend to continue with a new dedicated account (e.g. gitstream-cm ) in GitLab and install gitStream app with it. The service account has to have Maintainer role. Installation Step 1 of 4: Create a .cm/gitstream.cm rules file in the work repository default branch (usually master or main ) with the following contents: # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. code_experts : if : - true run : - action : add-comment@v1 # More info about explainCodeExperts: https://docs.gitstream.cm/filter-functions/#explaincodeexperts args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} Step 2 of 4: Create a new cm project (repository) in your GitLab group. It should be created in the same group or a parent group of the target repositories. Step 3 of 4: Create a ./.gitlab-ci.yml CI/CD file in the cm repository default branch (usually master or main ) with the following contents: # Code generated by gitStream - DO NOT EDIT stages : - gitstream-main image : docker:latest services : - docker:dind before_script : - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY gitstream-job : stage : gitstream-main only : variables : - $GITSTREAM_MAIN_JOB except : variables : - $GITSTREAM_BLOCK_MERGE script : - apk update && apk add git && apk add docker - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/ - cd gitstream && git fetch --all && git checkout $base_ref && git pull && ls && git checkout $head_ref && git pull && ls - docker pull gitstream/rules-engine:latest - | docker run -v $CI_PROJECT_DIR/gitstream:/code \\ -e HEAD_REF=$head_ref \\ -e BASE_REF=$base_ref \\ -e CLIENT_PAYLOAD=\"$client_payload\" \\ -e RULES_RESOLVER_URL=$resolver_url \\ -e RULES_RESOLVER_TOKEN=$resolver_token gitstream/rules-engine Step 4 of 4: Install gitStream app for GitLab . Next steps To learn how to add your first rule, jump to the Quick Start page. Configuration files Eventually, the following files should exist in each of the selected repos: In the cm repository: . \u251c\u2500 .gitlab-ci.yml In your target repository: . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm File and path Reason .cm/*.cm Under the repo's .cm directory, any file that ends with .cm will be used by gitStream to specify automation rules, you can edit these files .gitlab-ci.yml Used by gitStream to execute automation rules in your GitLab repo so source code doesn't get to outside services Permissions Attention When renaming or adding new repositories, you must re-authenticate gitStream in GitLab The required permissions are: Permissions Reason Read/Write API To get notified on MR changes and allow gitStream to approve MRs once all conditions are met Read repository To read and check rules over the code changes on monitored repositories Read user profile Used to identify users gitStream actions Automation rules by gitStream are executed on behalf of the user account used to install it. We recommend using a new dedicated account in GitLab for installing gitStream, e.g. gitstream","title":"GitLab Setup"},{"location":"gitlab-installation/#gitlab-installation","text":"Prerequisites: GitLab cloud GitLab runner v15 or higher Tip Automation rules by gitStream are executed on behalf of the user account used to install it. We recommend to continue with a new dedicated account (e.g. gitstream-cm ) in GitLab and install gitStream app with it. The service account has to have Maintainer role.","title":"GitLab installation"},{"location":"gitlab-installation/#installation","text":"Step 1 of 4: Create a .cm/gitstream.cm rules file in the work repository default branch (usually master or main ) with the following contents: # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. code_experts : if : - true run : - action : add-comment@v1 # More info about explainCodeExperts: https://docs.gitstream.cm/filter-functions/#explaincodeexperts args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} Step 2 of 4: Create a new cm project (repository) in your GitLab group. It should be created in the same group or a parent group of the target repositories. Step 3 of 4: Create a ./.gitlab-ci.yml CI/CD file in the cm repository default branch (usually master or main ) with the following contents: # Code generated by gitStream - DO NOT EDIT stages : - gitstream-main image : docker:latest services : - docker:dind before_script : - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY gitstream-job : stage : gitstream-main only : variables : - $GITSTREAM_MAIN_JOB except : variables : - $GITSTREAM_BLOCK_MERGE script : - apk update && apk add git && apk add docker - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/ - cd gitstream && git fetch --all && git checkout $base_ref && git pull && ls && git checkout $head_ref && git pull && ls - docker pull gitstream/rules-engine:latest - | docker run -v $CI_PROJECT_DIR/gitstream:/code \\ -e HEAD_REF=$head_ref \\ -e BASE_REF=$base_ref \\ -e CLIENT_PAYLOAD=\"$client_payload\" \\ -e RULES_RESOLVER_URL=$resolver_url \\ -e RULES_RESOLVER_TOKEN=$resolver_token gitstream/rules-engine Step 4 of 4: Install gitStream app for GitLab .","title":"Installation"},{"location":"gitlab-installation/#next-steps","text":"To learn how to add your first rule, jump to the Quick Start page.","title":"Next steps"},{"location":"gitlab-installation/#configuration-files","text":"Eventually, the following files should exist in each of the selected repos: In the cm repository: . \u251c\u2500 .gitlab-ci.yml In your target repository: . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm File and path Reason .cm/*.cm Under the repo's .cm directory, any file that ends with .cm will be used by gitStream to specify automation rules, you can edit these files .gitlab-ci.yml Used by gitStream to execute automation rules in your GitLab repo so source code doesn't get to outside services","title":"Configuration files"},{"location":"gitlab-installation/#permissions","text":"Attention When renaming or adding new repositories, you must re-authenticate gitStream in GitLab The required permissions are: Permissions Reason Read/Write API To get notified on MR changes and allow gitStream to approve MRs once all conditions are met Read repository To read and check rules over the code changes on monitored repositories Read user profile Used to identify users","title":"Permissions"},{"location":"gitlab-installation/#gitstream-actions","text":"Automation rules by gitStream are executed on behalf of the user account used to install it. We recommend using a new dedicated account in GitLab for installing gitStream, e.g. gitstream","title":"gitStream actions"},{"location":"how-it-works/","text":"How it works Every time a dev opens a new Pull Request or changes a Pull Request, gitStream is triggered. Next, the .cm file is used to determine which automatic actions are invoked based on their conditions. The resulting actions use Git provider API to achieve the desired outcome. Overview In general, the next steps are common practice of changing code in repo: Create a feature branch Commit changes Push branch to remote repo Open Pull Request gitGraph commit id: \"A\" commit id: \"B\" branch feature commit id: \"C\" commit id: \"D\" commit id: \"E\" checkout main commit id: \"F\" commit id: \"G\" When gitStream installed and configured, whenever a new PR is opened, several actors are running: Git provider API gitStream service which you have installed from the marketplace gitStream CI/CD script that is placed per the Git provider requirements gitStream agent that is executed by the CI/CD script Once a new PR is opened (or changed) the following process occurs: gitStream gets event for the new PR gitStream calls the CI/CD script The installed action pulls and runs gitStream action linear-b/gitstream-github-action@v1 . This action runs locally in the repo and relies on The current branch is used to check which automations are valid from .cm/gitstream.cm The action calls to gitStream app with metadata gitStream app returns results The list of applicable automations are sent to the gitStream service gitStream service iterates over the automations and invokes each action using Git provider APIs The PR gets updated according to the desired automations At the end, the PR is ready for further review or merge. The following diagram describes the flow: sequenceDiagram autonumber Git provider API->>gitStream app: new PR gitStream app->>gitStream CI/CD script: run activate gitStream CI/CD script gitStream CI/CD script->>gitStream CI/CD script: pull agent action gitStream CI/CD script->>gitStream in repo agent: run activate gitStream in repo agent gitStream in repo agent->>gitStream in repo agent: parse the `.cm` rules gitStream in repo agent->>gitStream app: API calls (metadata read-only) activate gitStream app gitStream app->>gitStream in repo agent: results deactivate gitStream app gitStream in repo agent->>gitStream app: applicable automations deactivate gitStream in repo agent deactivate gitStream CI/CD script loop per automation loop per action gitStream app->>gitStream app: execute action gitStream app->>Git provider API: update PR end end The branch diff The branch diff is defined as the difference between the current branch and the most recent commit in the main branch, which is shared between both branches. The main branch is also referenced as the target branch that the PR shall merge into (referred as the base branch on GitHub). Using this PR as an example: The git-diff is performed between commit H on the feature branch and the commit F on the main branch. gitGraph commit id: \"A\" commit id: \"B\" branch feature commit id: \"C\" commit id: \"D\" checkout main commit id: \"E\" commit id: \"F\" checkout feature merge main commit id: \"G\" commit id: \"H\" checkout main commit id: \"I\" commit id: \"J\" Automation results Eventually, the gitStream app shows the following statuses: Success - when the applicable automation finished and PR is good to go Neutral - when there aren't any applicable automations for the PR Failed - when the applicable automation finished without completion","title":"How it works"},{"location":"how-it-works/#how-it-works","text":"Every time a dev opens a new Pull Request or changes a Pull Request, gitStream is triggered. Next, the .cm file is used to determine which automatic actions are invoked based on their conditions. The resulting actions use Git provider API to achieve the desired outcome.","title":"How it works"},{"location":"how-it-works/#overview","text":"In general, the next steps are common practice of changing code in repo: Create a feature branch Commit changes Push branch to remote repo Open Pull Request gitGraph commit id: \"A\" commit id: \"B\" branch feature commit id: \"C\" commit id: \"D\" commit id: \"E\" checkout main commit id: \"F\" commit id: \"G\" When gitStream installed and configured, whenever a new PR is opened, several actors are running: Git provider API gitStream service which you have installed from the marketplace gitStream CI/CD script that is placed per the Git provider requirements gitStream agent that is executed by the CI/CD script Once a new PR is opened (or changed) the following process occurs: gitStream gets event for the new PR gitStream calls the CI/CD script The installed action pulls and runs gitStream action linear-b/gitstream-github-action@v1 . This action runs locally in the repo and relies on The current branch is used to check which automations are valid from .cm/gitstream.cm The action calls to gitStream app with metadata gitStream app returns results The list of applicable automations are sent to the gitStream service gitStream service iterates over the automations and invokes each action using Git provider APIs The PR gets updated according to the desired automations At the end, the PR is ready for further review or merge. The following diagram describes the flow: sequenceDiagram autonumber Git provider API->>gitStream app: new PR gitStream app->>gitStream CI/CD script: run activate gitStream CI/CD script gitStream CI/CD script->>gitStream CI/CD script: pull agent action gitStream CI/CD script->>gitStream in repo agent: run activate gitStream in repo agent gitStream in repo agent->>gitStream in repo agent: parse the `.cm` rules gitStream in repo agent->>gitStream app: API calls (metadata read-only) activate gitStream app gitStream app->>gitStream in repo agent: results deactivate gitStream app gitStream in repo agent->>gitStream app: applicable automations deactivate gitStream in repo agent deactivate gitStream CI/CD script loop per automation loop per action gitStream app->>gitStream app: execute action gitStream app->>Git provider API: update PR end end","title":"Overview"},{"location":"how-it-works/#the-branch-diff","text":"The branch diff is defined as the difference between the current branch and the most recent commit in the main branch, which is shared between both branches. The main branch is also referenced as the target branch that the PR shall merge into (referred as the base branch on GitHub). Using this PR as an example: The git-diff is performed between commit H on the feature branch and the commit F on the main branch. gitGraph commit id: \"A\" commit id: \"B\" branch feature commit id: \"C\" commit id: \"D\" checkout main commit id: \"E\" commit id: \"F\" checkout feature merge main commit id: \"G\" commit id: \"H\" checkout main commit id: \"I\" commit id: \"J\"","title":"The branch diff"},{"location":"how-it-works/#automation-results","text":"Eventually, the gitStream app shows the following statuses: Success - when the applicable automation finished and PR is good to go Neutral - when there aren't any applicable automations for the PR Failed - when the applicable automation finished without completion","title":"Automation results"},{"location":"quick-start/","text":"Quick Start First automation \u2013 adding labels Once completed installation, each of your PRs will get a label that shows the estimated review time, with color coding as you define in the cm file. Try it yourself! Open a PR with minor change to the repository README.md file, you don't have to merge these changes. Once your PR is open, wait for gitStream check to finish, then your PR should get a colored labeled with 1 min review label. When sharing the PR link in Slack, your reviewer will get to see the Estimated Review Time: Marking safe changes Next, let's add a new automation that checks for safe-changes . In the example below, we have defined documentation changes as safe changes. Note When editing the CM file, make sure to preserve the indentation in the examples, as CM like YAML uses Python-style indentation to indicate nesting. You can copy the text below and overwrite the default .cm/gitstream.cm file content. Note the new automation rule safe_changes . # -*- mode: yaml -*- manifest : version : 1.0 automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} safe_changes : if : - {{ files | allDocs }} run : - action : add-label@v1 args : label : 'safe-changes' # You can uncomment the following action to get gitStream to automatically approve # - action: approve@v1 calc : etr : {{ branch | estimatedReviewTime }} Try it yourself! Open a PR with some minor change to the repository's README.md file, you don't have to merge these changes. Once your PR is open and gitStream check has finished running, you should notice that gitStream added cm-changes label and all the automation results are now displayed as new comment in the PR. Note You can learn more about dry-run mode here , but the gist of it is that gitStream switch to simulation mode to allow you a safe place to check and test new rules before you merge them to the main branch. If you didn't get any syntax error, you should see the dry-run comment. Once you ready to update the autaomtion rules with the latest changes, undo the README.md file changes, and commit and merge the changes you did to the .cm/gitstream.cm file in order for these changes to take effect. Once again, let's open a new PR with some minor change to the repository's README.md file, you don't have to merge these changes. After gitStream check has finished you should see the green labeled with 1 min review label and \u2013 as you only changed a document \u2013 the safe-changes label will appear on the PR as well. Approving safe changes To approve safe-changes you should use the last PR, and uncomment the - action: approve@v1 (make sure to align the - list indicator of the action with the previous one) or just overwrite the .cm/gitstream.cm file with this content: # -*- mode: yaml -*- manifest : version : 1.0 automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} safe_changes : if : - {{ files | allDocs }} run : - action : add-label@v1 args : label : 'safe-changes' # You can uncomment the following action to get gitStream to automatically approve - action : approve@v1 calc : etr : {{ branch | estimatedReviewTime }} Again, gitStream will switch to dry-run mode, and you are up for it, just merge the changes to .cm/gitstream.cm to get safe changes approved by gitStream for your team. Well done! From now on, safe changes won't require developer's time to review and approve them. What's next Once you get the hang of it, you can set up more automation rules. You can explore the gitStream CM syntax , or go over the examples page, there you can choose various automation such as marking PRs with no tests, assigning the right reviewer \u2013 for example changes to the Japanese translation files can be automatically assigned to the right translator\u2026 Download automation files and add them to your repository .cm/ directory, experiment in dry-run mode, add labels and then switch to automatic actions. Tip The .cm directory is located in the repository root and contains the automation files. Multiple rules files are supported. This is only the beginning. With gitStream, you can create rules to automate your PRs. You understand what your team needs, and gitStream will help you get there. Something missing? If something is missing, create a new enhancement request in the project's issues page .","title":"Quick start"},{"location":"quick-start/#quick-start","text":"","title":"Quick Start"},{"location":"quick-start/#first-automation-adding-labels","text":"Once completed installation, each of your PRs will get a label that shows the estimated review time, with color coding as you define in the cm file. Try it yourself! Open a PR with minor change to the repository README.md file, you don't have to merge these changes. Once your PR is open, wait for gitStream check to finish, then your PR should get a colored labeled with 1 min review label. When sharing the PR link in Slack, your reviewer will get to see the Estimated Review Time:","title":"First automation \u2013 adding labels"},{"location":"quick-start/#marking-safe-changes","text":"Next, let's add a new automation that checks for safe-changes . In the example below, we have defined documentation changes as safe changes. Note When editing the CM file, make sure to preserve the indentation in the examples, as CM like YAML uses Python-style indentation to indicate nesting. You can copy the text below and overwrite the default .cm/gitstream.cm file content. Note the new automation rule safe_changes . # -*- mode: yaml -*- manifest : version : 1.0 automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} safe_changes : if : - {{ files | allDocs }} run : - action : add-label@v1 args : label : 'safe-changes' # You can uncomment the following action to get gitStream to automatically approve # - action: approve@v1 calc : etr : {{ branch | estimatedReviewTime }} Try it yourself! Open a PR with some minor change to the repository's README.md file, you don't have to merge these changes. Once your PR is open and gitStream check has finished running, you should notice that gitStream added cm-changes label and all the automation results are now displayed as new comment in the PR. Note You can learn more about dry-run mode here , but the gist of it is that gitStream switch to simulation mode to allow you a safe place to check and test new rules before you merge them to the main branch. If you didn't get any syntax error, you should see the dry-run comment. Once you ready to update the autaomtion rules with the latest changes, undo the README.md file changes, and commit and merge the changes you did to the .cm/gitstream.cm file in order for these changes to take effect. Once again, let's open a new PR with some minor change to the repository's README.md file, you don't have to merge these changes. After gitStream check has finished you should see the green labeled with 1 min review label and \u2013 as you only changed a document \u2013 the safe-changes label will appear on the PR as well.","title":"Marking safe changes"},{"location":"quick-start/#approving-safe-changes","text":"To approve safe-changes you should use the last PR, and uncomment the - action: approve@v1 (make sure to align the - list indicator of the action with the previous one) or just overwrite the .cm/gitstream.cm file with this content: # -*- mode: yaml -*- manifest : version : 1.0 automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} safe_changes : if : - {{ files | allDocs }} run : - action : add-label@v1 args : label : 'safe-changes' # You can uncomment the following action to get gitStream to automatically approve - action : approve@v1 calc : etr : {{ branch | estimatedReviewTime }} Again, gitStream will switch to dry-run mode, and you are up for it, just merge the changes to .cm/gitstream.cm to get safe changes approved by gitStream for your team. Well done! From now on, safe changes won't require developer's time to review and approve them.","title":"Approving safe changes"},{"location":"quick-start/#whats-next","text":"Once you get the hang of it, you can set up more automation rules. You can explore the gitStream CM syntax , or go over the examples page, there you can choose various automation such as marking PRs with no tests, assigning the right reviewer \u2013 for example changes to the Japanese translation files can be automatically assigned to the right translator\u2026 Download automation files and add them to your repository .cm/ directory, experiment in dry-run mode, add labels and then switch to automatic actions. Tip The .cm directory is located in the repository root and contains the automation files. Multiple rules files are supported. This is only the beginning. With gitStream, you can create rules to automate your PRs. You understand what your team needs, and gitStream will help you get there.","title":"What's next"},{"location":"quick-start/#something-missing","text":"If something is missing, create a new enhancement request in the project's issues page .","title":"Something missing?"},{"location":"troubleshooting/","text":"Troubleshooting I can't see any action running Did you install gitStream in your repo? Check that you see gitStream app on repository's Settings > GitHub apps: In case you don't see it, visit the marketplace and install it for free: https://github.com/marketplace/gitstream-by-linearb Did you set the workflow files correctly? Check you have placed these 2 files in your repository, with these exact names: .cm/gitstream.cm .github/workflows/gitstream.yml These files need to be committed to the repository default branch (usually master or main ). Check that you see \"gitStream workflow automation\" on the Action section in your repository: Next, if you see failed action, check out the details: Some organization limit which actions can run, in that case in the repository settings you should enable it: Is the PR in Draft mode? gitStream automations won't trigger for PRs that in Draft mode. I have rules that should have blocked merge, but the PR can be merged still For example, when using the set-required-approvals action, gitStream can ensure the PR got enough approvals before it can be merged. gitStream does that by running as a check and marking the check conclusion as failed. In order for the PR to be blocked, gitStream should be set as a required check in the repo: instructions here . I can't set gitStream as required check In order for gitStream to be listed as a required check, it needs to be triggered at least once in that repo. First create a new PR so gitStream is triggered. Check it under repository's Settings > Branches: I don't want gitStream to run on PRs that was generated by a bot You can edit the .github/workflows/gitstream.yml and uncomment the if line, you can edit and replace the bot name with the bot name you want to ignore ( dependabot[bot] in the example below): .github/workflows/gitstream.yml jobs : gitStream : timeout-minutes : 5 # uncomment this condition, if you don't want any automation on dependabot PRs if : github.actor != 'dependabot[bot]' runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 gitStream fails and I don't understand why gitStream check run can fail from different reasons, and these are shown in the check result. Missing workflow file When it says gitStream.cm Skipped \u2014 gitStream workflow file not found , it means that the GitHub action was not found, check again that you have this file in your rpeository root: .github/workflows/gitstream.yml , see instructions on GitHub installation . Syntax error in the cm files Clicking the Details button will show more information and context. You can add this automation to see details on context variable. How can I debug expressions and see their content? You can dump any context value to the PR comment. For example, to see the list of changed files, use: automations : show_changed_files : if : - true run : - action : add-comment@v1 args : comment : | FILES DUMP {{ files | dump | safe }} JS FILES DUMP {{ files | filter ( regex = r / \\ .js $ /) | dump | safe }} Download and add to your repo .cm directory gitStream fails with syntax error after adding new rules IntelliJ IDEA has automatic code styling for YAML that can break the .cm syntax, check the following Settings/Preferences | Editor | Code Style | YAML --> Spaces | Code braces and make sure it is unchecked. VS Code YAML plugin by Red Hat extension [vscode-yaml](https://github.com/redhat-developer/vscode-yaml) has automatic code styling for YAML that can break the .cm syntax, make sure you disable bracketSpacing { \"yaml.format.bracketSpacing\" : false , } Not here? Create a new issue in the project's issues","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#i-cant-see-any-action-running","text":"Did you install gitStream in your repo? Check that you see gitStream app on repository's Settings > GitHub apps: In case you don't see it, visit the marketplace and install it for free: https://github.com/marketplace/gitstream-by-linearb Did you set the workflow files correctly? Check you have placed these 2 files in your repository, with these exact names: .cm/gitstream.cm .github/workflows/gitstream.yml These files need to be committed to the repository default branch (usually master or main ). Check that you see \"gitStream workflow automation\" on the Action section in your repository: Next, if you see failed action, check out the details: Some organization limit which actions can run, in that case in the repository settings you should enable it: Is the PR in Draft mode? gitStream automations won't trigger for PRs that in Draft mode.","title":"I can't see any action running"},{"location":"troubleshooting/#i-have-rules-that-should-have-blocked-merge-but-the-pr-can-be-merged-still","text":"For example, when using the set-required-approvals action, gitStream can ensure the PR got enough approvals before it can be merged. gitStream does that by running as a check and marking the check conclusion as failed. In order for the PR to be blocked, gitStream should be set as a required check in the repo: instructions here .","title":"I have rules that should have blocked merge, but the PR can be merged still"},{"location":"troubleshooting/#i-cant-set-gitstream-as-required-check","text":"In order for gitStream to be listed as a required check, it needs to be triggered at least once in that repo. First create a new PR so gitStream is triggered. Check it under repository's Settings > Branches:","title":"I can't set gitStream as required check"},{"location":"troubleshooting/#i-dont-want-gitstream-to-run-on-prs-that-was-generated-by-a-bot","text":"You can edit the .github/workflows/gitstream.yml and uncomment the if line, you can edit and replace the bot name with the bot name you want to ignore ( dependabot[bot] in the example below): .github/workflows/gitstream.yml jobs : gitStream : timeout-minutes : 5 # uncomment this condition, if you don't want any automation on dependabot PRs if : github.actor != 'dependabot[bot]' runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1","title":"I don't want gitStream to run on PRs that was generated by a bot"},{"location":"troubleshooting/#gitstream-fails-and-i-dont-understand-why","text":"gitStream check run can fail from different reasons, and these are shown in the check result.","title":"gitStream fails and I don't understand why"},{"location":"troubleshooting/#missing-workflow-file","text":"When it says gitStream.cm Skipped \u2014 gitStream workflow file not found , it means that the GitHub action was not found, check again that you have this file in your rpeository root: .github/workflows/gitstream.yml , see instructions on GitHub installation .","title":"Missing workflow file"},{"location":"troubleshooting/#syntax-error-in-the-cm-files","text":"Clicking the Details button will show more information and context. You can add this automation to see details on context variable.","title":"Syntax error in the cm files"},{"location":"troubleshooting/#how-can-i-debug-expressions-and-see-their-content","text":"You can dump any context value to the PR comment. For example, to see the list of changed files, use: automations : show_changed_files : if : - true run : - action : add-comment@v1 args : comment : | FILES DUMP {{ files | dump | safe }} JS FILES DUMP {{ files | filter ( regex = r / \\ .js $ /) | dump | safe }} Download and add to your repo .cm directory","title":"How can I debug expressions and see their content?"},{"location":"troubleshooting/#gitstream-fails-with-syntax-error-after-adding-new-rules","text":"IntelliJ IDEA has automatic code styling for YAML that can break the .cm syntax, check the following Settings/Preferences | Editor | Code Style | YAML --> Spaces | Code braces and make sure it is unchecked. VS Code YAML plugin by Red Hat extension [vscode-yaml](https://github.com/redhat-developer/vscode-yaml) has automatic code styling for YAML that can break the .cm syntax, make sure you disable bracketSpacing { \"yaml.format.bracketSpacing\" : false , }","title":"gitStream fails with syntax error after adding new rules"},{"location":"troubleshooting/#not-here","text":"Create a new issue in the project's issues","title":"Not here?"}]}